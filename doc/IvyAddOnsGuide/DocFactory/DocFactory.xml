<?xml version="1.0" encoding="UTF-8"?>
<chapter version="5.0" xml:id="ivy.addons.docfactory" xmlns="http://docbook.org/ns/docbook"
  xmlns:ns6="http://www.w3.org/1999/xlink" xmlns:ns5="http://www.w3.org/1998/Math/MathML"
  xmlns:ns4="http://www.w3.org/2000/svg" xmlns:ns3="http://www.w3.org/1999/xhtml"
  xmlns:ns="http://docbook.org/ns/docbook">
  <title>DocFactory</title>
  <sect1 xml:id="ivy.addons.docfactory.purpose">
    <title>Purpose</title>
    <para>A Document Factory is a system that allows generating automatically documents like serial
      letters with the help of documents models like Microsoft Office Templates (.dot or .dotx
      files).</para>
    <para>The document Factory system in the Ivy Add-ons project is open and can be extended. At the
      moment it is only implemented with the commercial Java API Aspose (www.aspose.com). You can
      add your own implementation with another API. <link linkend="ivy.addons.docfactory.docfactory"
        >Read more</link> in the doc factory section below.</para>
    <para>This solution works with Microsoft Office Templates. Each template contains fixed text and
      dynamic merges fields. A Merge field is a placeholder for text information. Each merge field
      has a name and will be filled with the information you provide to the document Factory system.
      For example a merge field could be the address or the name of a correspondent for a letter.</para>
    <table>
      <title>Terms and Definitions used in the DocFactory chapter</title>
      <tgroup cols="2">
        <tbody>
          <row>
            <entry>Document Factory</entry>
            <entry>The document Factory System implemented in the Ivy Add-ons Project</entry>
          </row>
          <row>
            <entry>Template</entry>
            <entry>A Microsoft Office template (document model)</entry>
          </row>
          <row>
            <entry>Merge field</entry>
            <entry>Placeholder for text information in the template</entry>
          </row>
          <row>
            <entry>Document</entry>
            <entry>If not defined, this is a letter or document generated with the help of a
              template after the mail merging operation</entry>
          </row>
          <row>
            <entry>Mail merging</entry>
            <entry>Document generation with the replacement of the merge fields with the
              corresponding information</entry>
          </row>
          <row>
            <entry>Format</entry>
            <entry>The format in which the serial document has to be saved (doc, txt, html…)</entry>
          </row>
        </tbody>
      </tgroup>
    </table>
  </sect1>
  <sect1 xml:id="ivy.addons.docfactory.mailmerge">
    <title>Mail Merging</title>
    <para>Using templates allows for automatical generation of huge quantities of serial letters to
      different correspondents. It is widely used as a consistent way to unify the letter
      correspondence in companies or administrations. The mechanism of mail merging can be resumed
      with the following picture:</para>
    <mediaobject>
      <imageobject>
        <imagedata fileref="images/DocFactory/mailMerge.png"/>
      </imageobject>
    </mediaobject>
    <para>At the heart of the mechanism lies a Merge Mail Engine. This Engine receives some Data
      from a Data Source (DB, XML …) and replaces merge fields in the template with the
      corresponding information. It saves each letter as a separate document or in a document
      containing all the letters. The data should be in the form of a Data Set (list of
      correspondents’ addresses for example).</para>
    <para>In our Document Factory, the Mail Merge Engine is provided by the commercial Aspose Words
      Java API. You can extend and create your own implementation of the document Factory with other
      engines.</para>
  </sect1>
  <sect1 xml:id="ivy.addons.docfactory.mailmergeWithRegions">
    <title>Mail Merging with Regions</title>
    <ns:warning>
      <para>The mail merge with regions described here is specific to the Aspose engine. If you
        extend this current DocFactory by using another engine you have to refer to its specifical
        documentation.</para>
    </ns:warning>
    <para>If you want to dynamically grow portions inside the document, use mail merge with regions.
      To specify a mail merge region in the document you need to insert two mail merge fields to
      mark the beginning and end of the mail merge region. All document content that is included
      inside a mail merge region automatically will be repeated for every record in the data source
      (in most cases this is a table). </para>
    <para>To mark the beginning of a mail merge region, insert a MERGEFIELD with the name
      TableStart:MyTable, where MyTable corresponds to the name of the table. To mark the end of the
      mail merge region insert another MERGEFIELD with the name TableEnd:MyTable. Between these
      marking fields, place merge fields that correspond to the fields of your data source (table
      columns). </para>
    <para>These merge fields will be populated with data from the first row of the data source, then
      the whole region will be repeated, and the new fields will be populated with data from the
      second row, and so on. </para>
    <para>Follow these simple rules when marking a region: <itemizedlist>
        <listitem>
          <para>TableStart and TableEnd fields must be inside the same section in the
          document.</para>
        </listitem>
        <listitem>
          <para>If used inside a table,TableStart and TableEnd must be inside the same row in the
            table.</para>
        </listitem>
        <listitem>
          <para>Mail merge regions can be nested inside each other.</para>
        </listitem>
        <listitem>
          <para>Mail merge regions should be well formed (there is always a pair of matching
            TableStart and TableEnd with the same table name).</para>
        </listitem>
      </itemizedlist></para>
    <para>The following picture shows a template with a mail merge region:</para>
    <mediaobject>
      <imageobject>
        <imagedata fileref="images/DocFactory/templateWithMailMergeRegion.png"/>
      </imageobject>
    </mediaobject>
    <para>The following picture shows the result of the mail merge with regions:</para>
    <mediaobject>
      <imageobject>
        <imagedata fileref="images/DocFactory/resultMailMergeWithRegions.png"/>
      </imageobject>
    </mediaobject>
    <para>We have provided some callables subprocesses to ease the use of mail merge and mail merge
      with regions. Please refer to the <link linkend="ivy.addons.docfactory.docfactory">next
        section.</link>
    </para>
  </sect1>
  <sect1 xml:id="ivy.addons.docfactory.mailmergeWithNestedRegions">
    <title>Mail Merging with Nested Regions</title>
    <ns:warning>
      <para>The mail merge with nested regions described here is specific to the Aspose engine. If
        you extend this current DocFactory by using another engine you have to refer to its
        specifical documentation.</para>
    </ns:warning>
    <tip>
      <para>Most of the information provided in this section was retrieved from the aspose official
        documentation. You can find the complete documentation on the aspose web site at
        http://www.aspose.com. </para>
    </tip>
    <para>
      <literallayout>
        Most data in relational databases or XML files is hierarchical (e.g. with parent-child relationships). 
        One common example is a report about employees of a company. The different employees are employed in different departments and have for example several human capital elements. 
        In this case we have several Items nested in each other: Human Capital elements nested in Employees nested in Departments nested in a Company.
        
        Aspose.Words allows nesting mail merge regions inside each other in a document to reflect the way the data is nested and this allows you to
        easily populate a document with hierarchical data.
        Nested mail merge regions are at least two regions in which one is defined entirely inside
        the other, so they are “nested” in one another. In a document it looks like this:
      </literallayout>
    </para>
    <mediaobject>
      <imageobject>
        <imagedata fileref="images/DocFactory/NestedMailMerge01.png"/>
      </imageobject>
    </mediaobject>
    <para>There are a few things you need to consider when preparing nested mail merge regions and
      merge regions in general.</para>
    <para>
      <itemizedlist>
        <listitem>
          <para>The mail merge region opening and closing tag (e.g. TableStart:Order,
            TableEnd:Order) both need to appear in the same row or cell. For example, if you start a
            merge region in a cell of a table, you must end the merge region in the same row as the
            first cell.</para>
        </listitem>
        <listitem>
          <para>The names of the columns in the DataTable must match the merge field name. Unless
            you have specified mapped fields the merge will not be successful for those fields whose
            names are different. In the Ivy Implementation of this feature we use the Dataclasses
            Class names as TableStart names and the Dataclasses attributes names as mergefields
            names (more information <link linkend="ivy.addons.docfactory.nestedMailMergeMapping"
              >here). </link>
          </para>
        </listitem>
        <listitem>
          <para>Mail merge regions should be well formed (there is always a pair of matching
            TableStart and TableEnd with the same table name).</para>
        </listitem>
      </itemizedlist>
    </para>
    <para>The following picture shows a template with a mail merge region:</para>
    <mediaobject>
      <imageobject>
        <imagedata fileref="images/DocFactory/NestedMailMerge02.png"/>
      </imageobject>
    </mediaobject>
    <para>The following picture shows the result of the mail merge with regions:</para>
    <mediaobject>
      <imageobject>
        <imagedata fileref="images/DocFactory/NestedMailMerge03.png"/>
      </imageobject>
    </mediaobject>
    <para xml:id="ivy.addons.docfactory.nestedMailMergeMapping"> The previous nested mail merging
      was made by using List of Ivy DataClasses built as following: <mediaobject>
        <imageobject>
          <imagedata fileref="images/DocFactory/NestedMailMerge04.png"/>
        </imageobject>
      </mediaobject><emphasis role="bold"> It is very important to create your templates with this
        in mind: </emphasis><itemizedlist>
        <listitem>
          <para>Each TableStart merge field has to be named like the corresponding dataclass: e.g.
            the TableStart:Employee will correspond to the Employee data object. This rule is case
            sensitive.</para>
        </listitem>
        <listitem>
          <para>Within each "Data Object - Table" the merge fields will be filled with the
            corresponding data attribute value. The merge field must have the same name as the data
            attribute. E.g. the level attribute/mergefield in the HumanCapital table.</para>
        </listitem>
      </itemizedlist></para>
    <para>We have provided some callables subprocesses to ease the use of mail merge and mail merge
      with nested regions. Please refer to the <link linkend="ivy.addons.docfactory.docfactory">next
        section.</link>
    </para>
  </sect1>
  <sect1 xml:id="ivy.addons.docfactory.complexMergeFields">
    <title>Complex Mergefields (Field Update)</title>
    <para>
      <literallayout>
Aspose and its implementation in the docFactory allows using complex fields types like IF, NEXTIF, ADDRESSBLOCK etc...
The list of the fields type that are supported and the way they can be handled is explained here: http://www.aspose.com/docs/display/wordsjava/About+Field+Update
The DocFactory Demo uses an IF Mergefield to write a salutation depending on the gender of the person.
Such a Field can be inserted and viewed by using the Alt+F9 shortcut in the template. Please refer to your Office documentation to learn how to set these kinds of fields:
    </literallayout>
      <mediaobject>
        <imageobject>
          <imagedata fileref="images/DocFactory/IFMergerField.png"/>
        </imageobject>
      </mediaobject>
      <literallayout>To see such a conditional Field in action, please refer to the Demo with a dataclass</literallayout>
    </para>
  </sect1>
  <sect1 xml:id="ivy.addons.docfactory.callables">
    <title>Callable Processes for generating Serial Letters and documents</title>
    <para>Two Callable Processes are available from the AddOns project and at your disposal, to
      cover a maximum of your needs in the letter production. They use three kinds of Java Objects
      to perform their task.</para>
    <sect2>
      <title>Java Classes: TemplateMergeField, DocumentTemplate and FileOperationMessage</title>
      <para>The Java classes of those objects are located in the package
          <code>ch.ivyteam.ivy.addons.docfactory</code>.</para>
      <sect3>
        <title>TemplateMergeField</title>
        <para>The <code>TemplateMergeField</code> class is the representation of a merge field in a
          template. It has two fields: a name and a value, both a String. It is used to provide
          information to the Mail merge Engine to fill the corresponding merge fields in the
          template.</para>
        <table>
          <title><code>TemplateMergeField</code> attributes</title>
          <tgroup cols="3">
            <thead>
              <row>
                <entry>Field</entry>
                <entry>Type</entry>
                <entry>Description</entry>
              </row>
            </thead>
            <tbody>
              <row>
                <entry>mergeFieldName</entry>
                <entry>String</entry>
                <entry>Name of the merge field. If the <code>mergeFieldName</code> is in the form of
                  “Image:ImageName” or “Image_ImageName” where “Image:” or “Image_” is constant,
                  then this indicates that an image should be placed into the respective merge
                  field.</entry>
              </row>
              <row>
                <entry>mergeFieldValue</entry>
                <entry>String</entry>
                <entry>The value of the merge field. If image merge fields are used (see above) then
                  this indicates the path to the image, for example:
                    <code>file:///Icons/warning48.png</code> or <code>
                C:/Icons/warning48.png</code></entry>
              </row>
            </tbody>
          </tgroup>
        </table>
        <para>There is one constructor: <code>public TemplateMergeField(String mergeFieldName,
            String mergeFieldValue)</code>.</para>
      </sect3>
      <sect3>
        <title>FileOperationMessage</title>
        <para>The <code>FileOperationMessage</code> class is a convenience class to return the
          result of mail merging and File generation. It contains three variables:</para>
        <table>
          <title><code>FileOperationMessage</code> attributes</title>
          <tgroup cols="3">
            <thead>
              <row>
                <entry>Field</entry>
                <entry>Type</entry>
                <entry>Description</entry>
              </row>
            </thead>
            <tbody>
              <row>
                <entry>message</entry>
                <entry>String</entry>
                <entry>The text message to return (like “File generation successful” or “An error
                  occurred”…)</entry>
              </row>
              <row>
                <entry>type</entry>
                <entry>int</entry>
                <entry>Number indicating which kind of message it is (SUCCESS, ERROR OR
                  INFORMATION). The possible return values are available as static final constants
                  on this class.</entry>
              </row>
              <row>
                <entry>files</entry>
                <entry>List&lt;java.io.File&gt;</entry>
                <entry>All the Files produced during the mail merge operation. They can be used for
                  further actions like printing, editing, downloading….</entry>
              </row>
            </tbody>
          </tgroup>
        </table>
        <para>There are two constructors: The default constructor <code>public
            FileOperationMessage()</code>and <code>public FileOperationMessage(String message,
            List&lt;File&gt; files, int type)</code></para>
      </sect3>
      <sect3>
        <title xml:id="ivy.addons.docfactory.documentTemplate">DocumentTemplate</title>
        <para>The <code>DocumentTemplate</code> class represents a whole letter or document to be
          generated. It contains all the necessary information to be able to generate a new document
          with a mail merge engine. The information is placed into the following variables, each of
          them can be accessed through get/set methods:</para>
        <table>
          <title><code>DocumentTemplate</code> attributes</title>
          <tgroup cols="3">
            <thead>
              <row>
                <entry>Field</entry>
                <entry>Type</entry>
                <entry>Description</entry>
              </row>
            </thead>
            <tbody>
              <row>
                <entry>templatePath</entry>
                <entry>String</entry>
                <entry>File path of the template to use for the mail merging. This path is server
                  side.</entry>
              </row>
              <row>
                <entry>outputPath</entry>
                <entry>String</entry>
                <entry>The path of the folder where to store the produced document after mail
                  merging.</entry>
              </row>
              <row>
                <entry>outputName</entry>
                <entry>String</entry>
                <entry>The name of the File or produced document.</entry>
              </row>
              <row>
                <entry>outputFormat</entry>
                <entry>String</entry>
                <entry>The desired Format of the document (doc, docx…).</entry>
              </row>
              <row>
                <entry>mergeFields</entry>
                <entry>List&lt;TemplateMergeField></entry>
                <entry>The list of the Merge Fields: each merge field should be present into the
                  template. The values of the merge fields are going to be inserted into the
                  corresponding template’s merge fields. </entry>
              </row>
              <row>
                <entry>data</entry>
                <entry>CompositeObject (like an Ivy DataClass)</entry>
                <entry>The DocumentTemplate object accepts a DataClass as alternative to a List of
                  TemplateMergeFields. Each attribute of the dataclass will be linked with a
                  template merge field with the same name. The String value from the attributll be
                  taken to fill the corresponding mergefield.</entry>
              </row>
              <row>
                <entry>documentFactory</entry>
                <entry>BaseDocFactory</entry>
                <entry>This is the Engine responsible of the mail merging. See last section of this
                  chapter.</entry>
              </row>
              <row>
                <entry>fileOperationMessage</entry>
                <entry>FileOperationMessage</entry>
                <entry>The FileOperationMessage returned by the mail merging operation.</entry>
              </row>
              <row>
                <entry>tablesNamesAndFieldsmap*</entry>
                <entry>java.util.HashMap&lt;String, java.util.List&lt;CompositeObject>></entry>
                <entry>This parameter is used for mail merge with regions. This object consists of
                  key/values pairs, where the keys (String) are the table starts names and the lists
                  of CompositeObjects contain the datas. Each CompositeObject (Ivy DataClass)
                  represents a row in a table. The value of the dataclass attributes whose names
                  match mergefields' names of the table will used to fill these mergefields.</entry>
              </row>
              <row>
                <entry>tablesNamesAndFieldsHashtable*</entry>
                <entry>java.util.Hashtable&lt;String, Recordset></entry>
                <entry>This parameter is used for mail merge with regions. This object consists of
                  key/values pairs, where the keys (String) are the table starts names and the
                  recordsets contain the datas for the corresponding tables. Each Record represents
                  a row in a table. A Record's value will be inserted in the mergefield that
                  corresponds to its field's name.</entry>
              </row>
              <row>
                <entry>
                  <literallayout>List&lt;CompositeObject> parentDataSourceForNestedMailMerge and
List&lt;List&lt;CompositeObject>> childrenDataSourcesForNestedMailMerge</literallayout>
                </entry>
                <entry>
                </entry>
                <entry>
                  <literallayout> Used for mail merge with Nested regions. With these attributes set, only one nested level is supported:
the parent list contains the information for the parent table/region,
each child List&lt;CompositeObject> contains the information for one parent data object and is nested in this parent.
                </literallayout>
                </entry>
              </row>
              <row>
                <entry>
                  <literallayout>nestedDataSourceForNestedMailMerge</literallayout>
                </entry>
                <entry>
                  <literallayout>List&lt;CompositeObject></literallayout>
                </entry>
                <entry>
                  <literallayout>Used for mail merge with Nested regions. 
In this case each dataclass may contain lists of other nested dataclasses and so on... .
There is no limit in nesting regions.
 </literallayout>
                </entry>
              </row>
              <row>
                <entry>
                  <literallayout>treeData</literallayout>
                </entry>
                <entry>
                  <literallayout>Tree</literallayout>
                </entry>
                <entry>
                  <literallayout>Used for mail merge with Nested regions. There is no limit in nesting regions.
In this case the data structure corresponding to the nested regions in the template is stored in a Tree.
The first root node of the Tree contains a dataclass as value object. The attributes of this dataclass are used 
to fill merge fields outside of the nested regions area.
All the children nodes at each level of the Tree contain dataclasses as value that are used to fill the corresponding nested region.
                </literallayout>
                </entry>
              </row>
            </tbody>
          </tgroup>
        </table>
        <para>* The two attributes tablesNamesAndFieldsmap and tablesNamesAndFieldsHashtable cannot
          be used together to perform mail merge with regions. If one is set, then the other one is
          cleared. So you have to decide if you use Recordsets or List of CompositeObjects to fill
          your merge regions.</para>
        <para>There are several constructors, that are all documented in javadoc style: <itemizedlist>
            <listitem>
              <para>The default constructor <code>public DocumentTemplate()</code>,</para>
            </listitem>
            <listitem>
              <para><code>public DocumentTemplate(String _templatePath, String _outputPath, String
                  _outputName, String _outputFormat, List&lt;TemplateMergeField>
                _mergeFields)</code></para>
            </listitem>
            <listitem>
              <para><code>public DocumentTemplate(String _templatePath, String _outputPath, String
                  _outputName, String _outputFormat, List&lt;TemplateMergeField> _mergeFields,
                  Hashtable&lt;String , Recordset> _tablesNamesAndFieldsHashtable)</code></para>
            </listitem>
            <listitem>
              <para><code>public DocumentTemplate(String _templatePath, String _outputPath, String
                  _outputName, String _outputFormat, List&lt;TemplateMergeField> _mergeFields,
                  HashMap&lt;String , java.util.List&lt;CompositeObject>>
                _tablesNamesAndFieldsmap)</code></para>
            </listitem>
            <listitem>
              <para><code>public DocumentTemplate(String _templatePath, String _outputPath, String
                  _outputName, String _outputFormat, CompositeObject _data)</code></para>
            </listitem>
            <listitem>
              <para><code>public DocumentTemplate(String _templatePath, String _outputPath, String
                  _outputName, String _outputFormat, CompositeObject _data, HashMap&lt;String ,
                  java.util.List&lt;CompositeObject>> _tablesNamesAndFieldsmap)</code></para>
            </listitem>
            <listitem>
              <para><code>public DocumentTemplate(String _templatePath, String _outputPath, String
                  _outputName, String _outputFormat, CompositeObject _data, Hashtable&lt;String ,
                  Recordset> _tablesNamesAndFieldsHashtable)</code></para>
            </listitem>
            <listitem>
              <para><code>public DocumentTemplate(String _templatePath, String _outputPath, String
                  _outputName, String _outputFormat, CompositeObject _data, List&lt;CompositeObject>
                  _parentDataSourceForNestedMailMerge,List&lt;List&lt;CompositeObject>>
                  _childrenDataSourcesForNestedMailMerge)</code></para>
            </listitem>
            <listitem>
              <para><code>public DocumentTemplate(String _templatePath, String _outputPath, String
                  _outputName, String _outputFormat, CompositeObject _data, List&lt;CompositeObject>
                  _nestedDataSourceForNestedMailMerge)</code></para>
            </listitem>
            <listitem>
              <para><code>public DocumentTemplate(String _templatePath, String _outputPath, String
                  _outputName, String _outputFormat, Tree _treeData)</code></para>
            </listitem>
          </itemizedlist></para>
      </sect3>
    </sect2>
    <sect2>
      <title>Callable Processes</title>
      <para>Two callable processes are available to ease usage of the document factory. They are
        located in the IvyAddOns <emphasis>Functional Processes</emphasis> folder:</para>
      <mediaobject>
        <imageobject>
          <imagedata fileref="images/DocFactory/callables.png"/>
        </imageobject>
      </mediaobject>
      <sect3>
        <title>writeSerialLetterToOneCorrespondent</title>
        <para>The Callable named <code>writeSerialLetterToOneCorrespondent</code> contains seven
          callable subcess starts. </para>
        <para>The first one (writeSerialLetterToOneCorrespondant) allows writing a single document
          with a template by providing a single list of <code>TemplateMergeField</code> objects.
          Here is the description of this callable that you can find in the ivy process mod file:</para>
        <mediaobject>
          <imageobject>
            <imagedata fileref="images/DocFactory/callable1.png"/>
          </imageobject>
        </mediaobject>
        <para>The second one (writeDocumentWithOneDataClass) allows writing a single document with a
          template by providing a <code>CompositeObject (DataClass)</code> . Here is the description
          of this callable that you can find in the ivy process mod file:</para>
        <mediaobject>
          <imageobject>
            <imagedata fileref="images/DocFactory/callable3.png"/>
          </imageobject>
        </mediaobject>
        <para>Other ones (writeDocumentWithMailMergeTable) allow writing a single document with a
          template that can contain merge mail with regions (tables) . Here is the description of
          this callable that you can find in the ivy process mod file:</para>
        <mediaobject>
          <imageobject>
            <imagedata fileref="images/DocFactory/callable4.png"/>
          </imageobject>
        </mediaobject>
        <para>The last three ones allows writing a single document with a template that can contain
          merge mail with nested regions (tables).
          <literallayout>
            writeDocumentWithMailMergeNestedTable(String,String,String,String, List&lt;CompositeObject>,List&lt;List&lt;CompositeObject>>)
            writeDocumentWithMailMergeNestedTableWithTree(String,String,String,String,Tree)
            writeDocumentWithMailMergeNestedTableWithListOfDatas(String,String,String,String,CompositeObject, List&lt;CompositeObject>)
          </literallayout></para>
        <mediaobject>
          <imageobject>
            <imagedata fileref="images/DocFactory/NestedMailMerge05.png"/>
          </imageobject>
        </mediaobject>
      </sect3>
      <sect3>
        <title>writeSerialLetterToManyCorrespondents</title>
        <para>The callable named <code>writeSerialLetterToManyCorrespondents</code> allows writing
          more than one document with a list of <code>DocumentTemplate</code> objects. Each
            <code>DocumentTemplate</code> object is going to produce a document. Merge mail with
          regions and merge mail with nested regions are now supported, because the DocumentTemplate
          Object encapsulates the necessary parameters to perform such merges (see the <link
            linkend="ivy.addons.docfactory.documentTemplate">DocumentTemplate documentation</link>).
          Here is the description of this callable that you can find in the ivy process mod file:</para>
        <mediaobject>
          <imageobject>
            <imagedata fileref="images/DocFactory/callable2.png"/>
          </imageobject>
        </mediaobject>
      </sect3>
    </sect2>
  </sect1>
  <sect1 xml:id="ivy.addons.docfactory.demos">
    <title>Demos</title>
    <para>Two demos are available in the <emphasis>IvyDemos</emphasis> project that demonstrate the
      usage of the DocFactory: one for the mail merging and mail merge with regions, and one for the
      nested mail merge with regions (Reporting).</para>
    <sect2 xml:id="ivy.addons.docfactory.demos1">
      <title> Mail merging and mail merge with regions</title>
      <para>For that purpose, three default templates have been included into the CMS of the ivy
        demo project. They are located under “/docfactory/templatecache/myTemplate”,
        “/docfactory/templatecache/myTemplateWithDynamicPicture” and
        “/docfactory/templatecache/myTemplateWithTable” as MS World documents (.doc format).</para>
      <mediaobject>
        <imageobject>
          <imagedata fileref="images/DocFactory/demoTemplates.png"/>
        </imageobject>
      </mediaobject>
      <para>You can use the cms designer “Export to File” option, to save them as doc Files and to
        be able to look into them.</para>
      <para>They both contain three text fields (Name, Firstname, Address). All the documents
        produced are going to be saved into the “ivy_RIA_files” designer or server directory. The
        second one contains also a picture field, to illustrate the use of dynamic image merge
        fields, and the third one contains a merge mail region (table). </para>
      <para>The demo shows how to generate serial documents and the template with merge regions is
        used. All the serial documents are going to be generated into the
        <filename>ivy_RIA_files</filename> directory of your Server or Designer installation. </para>
      <mediaobject>
        <imageobject>
          <imagedata fileref="images/DocFactory/theDemo.png"/>
        </imageobject>
      </mediaobject>
      <para>The data for mail merge with regions is put into a Recordset that is used in an
        Hashtable to be inserted into the "reporting" region of the template. Here is the code for
        this operation: </para>
      <mediaobject>
        <imageobject>
          <imagedata fileref="images/DocFactory/recordsetCode.png"/>
        </imageobject>
      </mediaobject>
      <para>The following result is produced:</para>
      <mediaobject>
        <imageobject>
          <imagedata fileref="images/DocFactory/demoResults.png"/>
        </imageobject>
      </mediaobject>
      <para>A new button is also available to illustrate the use of a Dataclass as input parameter.
        A Panel is used to fill the Person Dataclass. This Dataclass contains 4 attributes (gender,
        name, firstname, address) that are going to be used to fill the template. The gender
        attribute is used in an IF Field to output the salutation, the other will fill "classical"
        mergefields.</para>
      <para>In this demo the following template is used (viewed with the detailed template veiw
        accessible with Alt+F9 shortcut):</para>
      <mediaobject>
        <imageobject>
          <imagedata fileref="images/DocFactory/newDemo4.png"/>
        </imageobject>
      </mediaobject>
      <mediaobject>
        <imageobject>
          <imagedata fileref="images/DocFactory/newDemo1.png"/>
        </imageobject>
      </mediaobject>
      <mediaobject>
        <imageobject>
          <imagedata fileref="images/DocFactory/newDemo2.png"/>
        </imageobject>
      </mediaobject>
      <mediaobject>
        <imageobject>
          <imagedata fileref="images/DocFactory/newDemo3.png"/>
        </imageobject>
      </mediaobject>
    </sect2>
    <sect2 xml:id="ivy.addons.docfactory.demos2">
      <title> Mail merge with nested regions</title>
      <para>For that purpose, one template have been included into the CMS of the ivy demo project.
        They are located under “/docfactory/templatecache/myReporting1”,
        “/docfactory/templatecache/myTemplateWithDynamicPicture” and
        “/docfactory/templatecache/myTemplateWithTable” as MS World documents (.doc format). You can
        use the cms designer “Export to File” option, to save it as doc Files and to be able to look
        into it.</para>
      <para>This template contains some merge fields that are external to the mail merge regions and
        nested mail merge regions.</para>
      <para>The demo shows how to generate serial documents and the template with merge regions is
        used. All the serial documents are going to be generated into the
        <filename>ivy_RIA_files</filename> directory of your Server or Designer installation. </para>
      <mediaobject>
        <imageobject>
          <imagedata fileref="images/DocFactory/startReportingDemo.png"/>
        </imageobject>
      </mediaobject>
      <para>Three ways to produce the reporting with nested regions are illustrated:</para>
      <mediaobject>
        <imageobject>
          <imagedata fileref="images/DocFactory/ReportingDemo.png"/>
        </imageobject>
      </mediaobject>
      <para>Please refer to the following Rich Dialog to learn more about the details of the
        creation of the needed datas, and about the way to use the provided callables:<emphasis
          role="bold">
        /IvyDemos/src_rd/ch/ivyteam/ivy/demo/docfactory/DocFactoryReporting/</emphasis></para>
    </sect2>
  </sect1>
  <sect1 xml:id="ivy.addons.docfactory.docfactory">
    <title>The Document Factory Object</title>
    <para>The Document Factory Object in this Ivy Addons implementation is made with the help of the
      commercial Aspose Java API. To be able to allow developing other Document Factories that work
      the same way as this one, a DocumentFactory implementation should always extend the abstract
      class <code>ch.ivyteam.ivy.addons.docfactory.BaseDocFactory</code> and must provide a default
      constructor (no arguments).</para>
    <para>This Class declares all the public methods a document factory should implement. For
      example it declares the <code>generateDocument(..)</code> method that takes a
        <code>DocumentTemplate</code> as parameter and returns a <code>FileOperationMessage</code>
      as result.</para>
    <para>The <code>AsposeDocFactory</code> is the provided default implementation of this
        <code>BaseDocFactory</code>. It is easy to get an instance of an AsposeDocFactory: The
      public static method <code>BaseDocFactory.getInstance()</code> returns such an object.</para>
    <para>If you want to use your own implementation class of the BaseDocFactory, you have to set a
      special Java System property on the server that gives the exact qualified name of your
      document factory class. The name of this property has to be “document.factory” and its value
      has to be “com.acme.docfactory.MyDocFactory”, for example, to name your own implementation.
      The getInstance() method of the BaseDocFactory will then return an instance of your document
      factory class.</para>
    <table>
      <title>Overview of the abstract <code>BaseDocFactory</code> methods</title>
      <tgroup cols="4">
        <thead>
          <row>
            <entry>Method</entry>
            <entry>Arguments</entry>
            <entry>Return Type</entry>
            <entry>Description</entry>
          </row>
        </thead>
        <tbody>
          <row>
            <entry>generateBlankDocument</entry>
            <entry>String outputName, String outputPath, String outputFormat</entry>
            <entry>FileOperationMessage</entry>
            <entry>Creates a blank document (for testing purposes).</entry>
          </row>
          <row>
            <entry>generateDocument</entry>
            <entry>String templatePath, String fileName, String outputPath, String _outputFormat,
              List&lt;TemplateMergeField&gt; list</entry>
            <entry>FileOperationMessage</entry>
            <entry>Creates a blank document (for testing purposes).</entry>
          </row>
          <row>
            <entry>generateDocument</entry>
            <entry>DocumentTemplate documentTemplate</entry>
            <entry>FileOperationMessage</entry>
            <entry>Creates one document.</entry>
          </row>
          <row>
            <entry>generateTxt</entry>
            <entry>String templatePath, List&lt;TemplateMergeField&gt; list</entry>
            <entry>String</entry>
            <entry>Creates a text string that is the result of the mail merge.</entry>
          </row>
          <row>
            <entry>generateHTML</entry>
            <entry>String templatePath, List&lt;TemplateMergeField&gt; list</entry>
            <entry>String</entry>
            <entry>Creates an HTML String that is the result of the mail merge.</entry>
          </row>
          <row>
            <entry>generateFilesForHTML</entry>
            <entry>String templatePath, List&lt;TemplateMergeField&gt; list</entry>
            <entry>ArrayList&lt;java.io.File&gt;</entry>
            <entry>Generates a list of Files that can be used for HTML representation.</entry>
          </row>
          <row>
            <entry>generateDocuments</entry>
            <entry>List&lt;DocumentTemplate&gt; list</entry>
            <entry>FileOperationMessage</entry>
            <entry>Generates one or more documents.</entry>
          </row>
          <row>
            <entry>generateDocuments</entry>
            <entry>String templatePath, String outputPath,String outputFormat,
              List&lt;List&lt;TemplateMergeField&gt;&gt; list</entry>
            <entry>FileOperationMessage</entry>
            <entry>Generates one or more documents each one can be saved in a different destination
              folder.</entry>
          </row>
          <row>
            <entry>generateDocumentsWithDifferentDestination</entry>
            <entry>String templatePath, String outputFormat,
              List&lt;List&lt;TemplateMergeField&gt;&gt; list</entry>
            <entry>FileOperationMessage</entry>
            <entry>Generates a list of Files that can be used for HTML representation.</entry>
          </row>
          <row>
            <entry>generateDocumentsWithDifferentDestination</entry>
            <entry>List&lt;DocumentTemplate&gt; list</entry>
            <entry>List&lt;FileOperationMessage&gt;</entry>
            <entry>Generates one or more documents. One FileOperationMessage for each
            document.</entry>
          </row>
          <row>
            <entry>generateMultipleDocumentsInOne</entry>
            <entry>String templatePath, String outputName, String outputPath, String outputFormat,
              List&lt;List&lt;TemplateMergeField&gt;&gt; list</entry>
            <entry>FileOperationMessage</entry>
            <entry>Generates multiple documents appended in one File.</entry>
          </row>
          <row>
            <entry>generateMultipleDocumentsInOne</entry>
            <entry>String templatePath, String outputName, String outputPath, String outputFormat,
              List&lt;DocumentTemplate&gt; templates</entry>
            <entry>FileOperationMessage</entry>
            <entry>Generates multiple documents appended in one File.</entry>
          </row>
          <row>
            <entry>generateDocumentWithRegions</entry>
            <entry>String _templatePath, String _outputName, String _outputPath, String
              _outputFormat, List&gt;TemplateMergeField> _mergefields, HashMap&gt;String,
              List&gt;CompositeObject>> _tablesNamesAndFieldsmap</entry>
            <entry>FileOperationMessage</entry>
            <entry>Method to generate one document with merge mail. Mail Merge with regions
              supported..</entry>
          </row>
          <row>
            <entry>generateDocumentWithRegions</entry>
            <entry>String _templatePath, String _outputName, String _outputPath, String
              _outputFormat, List&gt;TemplateMergeField> _mergefields, Hashtable&gt;String,
              Recordset> _hashtable</entry>
            <entry>FileOperationMessage</entry>
            <entry>Method to generate one document with merge mail. Mail Merge with regions
              supported.</entry>
          </row>
          <row>
            <entry>generateDocumentWithRegions</entry>
            <entry>String _templatePath, String _outputName, String _outputPath, String
              _outputFormat, List&gt;TemplateMergeField> _mergefields, List&gt;String> _tablesNames,
              List&gt;List&gt;String>> _tables_fieldsNames, List&gt;List&gt;List&gt;Object>>>
              tables_rowsValues</entry>
            <entry>FileOperationMessage</entry>
            <entry>Method to generate one document with merge mail. Mail Merge with regions
              supported.</entry>
          </row>
          <row>
            <entry>getTemplateFields</entry>
            <entry>String templatePath</entry>
            <entry>ArrayList&lt;String&gt;</entry>
            <entry>Returns the list of the Merge Fields names in a template.</entry>
          </row>
          <row>
            <entry>getFactoryClass</entry>
            <entry>-</entry>
            <entry>Class</entry>
            <entry>Get the Class of the current BaseDocFactory implementation class</entry>
          </row>
          <row>
            <entry>isFormatSupported</entry>
            <entry>String format</entry>
            <entry>boolean</entry>
            <entry>This method should check if the format denoted by the String param is supported
              by your document Factory.</entry>
          </row>
        </tbody>
      </tgroup>
    </table>
  </sect1>
</chapter>
