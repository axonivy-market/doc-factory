[Ivy]
124971223DD62955 9.2.0 #module
>Proto >Proto Collection #zClass
wr0 writeSerialLetter Big #zClass
wr0 B #cInfo
wr0 #process
wr0 @TextInP .xml .xml #zField
wr0 @TextInP .responsibility .responsibility #zField
wr0 @AnnotationInP-0n ai ai #zField
wr0 @MessageFlowInP-0n messageIn messageIn #zField
wr0 @MessageFlowOutP-0n messageOut messageOut #zField
wr0 @TextInP .type .type #zField
wr0 @TextInP .processKind .processKind #zField
wr0 @StartSub f0 '' #zField
wr0 @EndSub f1 '' #zField
wr0 @GridStep f4 '' #zField
wr0 @GridStep f7 '' #zField
wr0 @PushWFArc f6 '' #zField
wr0 @PushWFArc f2 '' #zField
wr0 @GridStep f3 '' #zField
wr0 @PushWFArc f5 '' #zField
wr0 @PushWFArc f8 '' #zField
wr0 @InfoButton f9 '' #zField
wr0 @StartSub f10 '' #zField
wr0 @InfoButton f11 '' #zField
wr0 @GridStep f12 '' #zField
wr0 @PushWFArc f13 '' #zField
wr0 @GridStep f14 '' #zField
wr0 @PushWFArc f15 '' #zField
wr0 @GridStep f16 '' #zField
wr0 @PushWFArc f17 '' #zField
wr0 @GridStep f18 '' #zField
wr0 @PushWFArc f19 '' #zField
wr0 @EndSub f20 '' #zField
wr0 @PushWFArc f21 '' #zField
wr0 @StartSub f22 '' #zField
wr0 @GridStep f23 '' #zField
wr0 @GridStep f24 '' #zField
wr0 @GridStep f25 '' #zField
wr0 @PushWFArc f26 '' #zField
wr0 @PushWFArc f27 '' #zField
wr0 @PushWFArc f28 '' #zField
wr0 @EndSub f29 '' #zField
wr0 @PushWFArc f30 '' #zField
wr0 @StartSub f31 '' #zField
wr0 @GridStep f32 '' #zField
wr0 @GridStep f33 '' #zField
wr0 @GridStep f34 '' #zField
wr0 @PushWFArc f35 '' #zField
wr0 @PushWFArc f36 '' #zField
wr0 @PushWFArc f37 '' #zField
wr0 @EndSub f38 '' #zField
wr0 @PushWFArc f39 '' #zField
wr0 @StartSub f40 '' #zField
wr0 @GridStep f41 '' #zField
wr0 @GridStep f42 '' #zField
wr0 @GridStep f43 '' #zField
wr0 @PushWFArc f44 '' #zField
wr0 @PushWFArc f45 '' #zField
wr0 @PushWFArc f46 '' #zField
wr0 @EndSub f47 '' #zField
wr0 @PushWFArc f48 '' #zField
wr0 @InfoButton f49 '' #zField
wr0 @StartSub f50 '' #zField
wr0 @GridStep f51 '' #zField
wr0 @GridStep f52 '' #zField
wr0 @GridStep f53 '' #zField
wr0 @GridStep f54 '' #zField
wr0 @PushWFArc f55 '' #zField
wr0 @PushWFArc f56 '' #zField
wr0 @PushWFArc f57 '' #zField
wr0 @PushWFArc f58 '' #zField
wr0 @EndSub f59 '' #zField
wr0 @PushWFArc f60 '' #zField
wr0 @StartSub f61 '' #zField
wr0 @GridStep f62 '' #zField
wr0 @GridStep f63 '' #zField
wr0 @GridStep f64 '' #zField
wr0 @GridStep f65 '' #zField
wr0 @PushWFArc f66 '' #zField
wr0 @PushWFArc f67 '' #zField
wr0 @PushWFArc f68 '' #zField
wr0 @PushWFArc f69 '' #zField
wr0 @EndSub f70 '' #zField
wr0 @PushWFArc f71 '' #zField
wr0 @StartSub f72 '' #zField
wr0 @GridStep f73 '' #zField
wr0 @GridStep f74 '' #zField
wr0 @GridStep f75 '' #zField
wr0 @PushWFArc f76 '' #zField
wr0 @PushWFArc f77 '' #zField
wr0 @PushWFArc f78 '' #zField
wr0 @EndSub f79 '' #zField
wr0 @PushWFArc f80 '' #zField
wr0 @GridStep f81 '' #zField
wr0 @GridStep f82 '' #zField
wr0 @GridStep f83 '' #zField
wr0 @StartSub f84 '' #zField
wr0 @PushWFArc f85 '' #zField
wr0 @PushWFArc f86 '' #zField
wr0 @PushWFArc f87 '' #zField
wr0 @EndSub f88 '' #zField
wr0 @PushWFArc f89 '' #zField
wr0 @StartSub f90 '' #zField
wr0 @GridStep f91 '' #zField
wr0 @GridStep f92 '' #zField
wr0 @GridStep f93 '' #zField
wr0 @PushWFArc f94 '' #zField
wr0 @PushWFArc f95 '' #zField
wr0 @PushWFArc f96 '' #zField
wr0 @EndSub f97 '' #zField
wr0 @PushWFArc f98 '' #zField
wr0 @InfoButton f99 '' #zField
wr0 @StartSub f100 '' #zField
wr0 @EndSub f101 '' #zField
wr0 @GridStep f102 '' #zField
wr0 @GridStep f103 '' #zField
wr0 @GridStep f104 '' #zField
wr0 @GridStep f105 '' #zField
wr0 @PushWFArc f106 '' #zField
wr0 @PushWFArc f107 '' #zField
wr0 @PushWFArc f108 '' #zField
wr0 @PushWFArc f109 '' #zField
wr0 @PushWFArc f110 '' #zField
>Proto wr0 wr0 writeSerialLetter #zField
wr0 f0 inParamDecl '<List<ch.ivyteam.ivy.addons.docfactory.TemplateMergeField> listOfTemplateMergeFields,String optionalOutputpath,String optionalLetterName,String optionalOutputFormat,String templatePath> param;' #txt
wr0 f0 inParamInfo 'listOfTemplateMergeFields.description=Each TemplateMergeField holds a key which is the mergefield name and the value which will be written in the document at the place of the corresponding mergefield.
optionalLetterName.description=Produced document name (default is "letter" + nanotime)
optionalOutputFormat.description=Output format among "doc", "docx", "pdf", "txt", "html". Default is "doc".
optionalOutputpath.description=Output directory path (default is ''%IVY-ROOT-PATH%/ivy_RIA_files/)
templatePath.description=The template path. ' #txt
wr0 f0 inParamTable 'out.mergeFieldsList=param.listOfTemplateMergeFields;
out.outputFormat=param.optionalOutputFormat;
out.outputPath=param.optionalOutputpath;
out.serialLetterName=param.optionalLetterName;
out.templatePath=param.templatePath;
' #txt
wr0 f0 outParamDecl '<ch.ivyteam.ivy.addons.docfactory.FileOperationMessage fileOperationMessage> result;' #txt
wr0 f0 outParamInfo 'fileOperationMessage.description=Result containing a Type indicating if the operation was successfull, a message in the Session User language, a list of java.io.File that were created during the process.' #txt
wr0 f0 outParamTable 'result.fileOperationMessage=in.fileOperationMessage;
' #txt
wr0 f0 callSignature writeSerialLetterToOneCorrespondant(List<ch.ivyteam.ivy.addons.docfactory.TemplateMergeField>,String,String,String,String) #txt
wr0 f0 @C|.xml '<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<elementInfo>
    <language>
        <name>writeSerialLetterToOneCorrespondant</name>
        <nameStyle>35,7,9
</nameStyle>
        <desc>This callable writes a letter to one Correspondant
with the help of a document factory Object.
The Document Factory Object is a Java Object that can parse a document model
that contains mergefields and replace those mergefields by some String Data.

This callable takes some mandatory and some optional input parameters.
Mandatory input Parameters:
-&gt; TemplatePath: this is the path of the template (document model)
-&gt; list of TemplateMergeFields. Each mergefield corresponds to a mergeField in the template.
If ne correspondance for a MergeField was found, it will be simply ignored.
Optional input parameters:
-&gt; optionalOutputPath: where to store the created java.io.File. By default &quot;ivy_RIA_files&quot;
-&gt; optionalOutputFormat: by default the first supported one (in general it will be &quot;doc&quot;
-&gt; optionalLetterName: the file name of the letter. By default &quot;letter&quot;+ the nanoTime, 
to be sure the file doesn''t overwrite any other.

It returns a FileOperationMessage Object that contains:
a Type indicating if the operation was successfull,
a message in the Session User language,
a list of java.io.File that were created during the porcess.

In this callable, just one java.io.File should be created.</desc>
    </language>
</elementInfo>
' #txt
wr0 f0 139 67 26 26 -98 -38 #rect
wr0 f0 res:/webContent/icons/doc-factory-logo.png?small #fDecoratorIcon
wr0 f1 139 363 26 26 14 0 #rect
wr0 f1 res:/webContent/icons/doc-factory-logo.png?small #fDecoratorIcon
wr0 f4 actionTable 'out=in;
' #txt
wr0 f4 actionCode 'import ch.ivyteam.ivy.addons.docfactory.BaseDocFactory;
in.documentFactory= BaseDocFactory.getInstance();' #txt
wr0 f4 @C|.xml '<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<elementInfo>
    <language>
        <name>make the documentFactory 
Object</name>
        <nameStyle>32,7,9
</nameStyle>
    </language>
</elementInfo>
' #txt
wr0 f4 134 140 36 24 22 -15 #rect
wr0 f7 actionTable 'out=in;
' #txt
wr0 f7 actionCode '
out.fileOperationMessage = 
in.documentFactory.generateDocument(in.templatePath,in.serialLetterName,in.outputPath,in.outputFormat,in.mergeFieldsList);' #txt
wr0 f7 @C|.xml '<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<elementInfo>
    <language>
        <name>write the serialLetter</name>
        <nameStyle>22,9
</nameStyle>
    </language>
</elementInfo>
' #txt
wr0 f7 134 292 36 24 22 -9 #rect
wr0 f6 expr out #txt
wr0 f6 152 316 152 363 #arcP
wr0 f2 expr out #txt
wr0 f2 152 93 152 140 #arcP
wr0 f3 actionTable 'out=in;
' #txt
wr0 f3 actionCode 'import ch.ivyteam.ivy.addons.docfactory.FileUtil;

// if desired format not valid, we take the first supportedFormat
if(in.#outputFormat == null || in.outputFormat.trim().equalsIgnoreCase("") 
	|| !in.documentFactory.isFormatSupported(in.outputFormat)){
	if(in.documentFactory.getSupportedFormats().size()>0){
		out.outputFormat=in.documentFactory.getSupportedFormats().get(0);
	}
}

//if desired letter name not valid, we take the name "letter_nanoTime()"
if(in.#serialLetterName == null || in.serialLetterName.trim().equalsIgnoreCase("")
	|| !ch.ivyteam.ivy.addons.docfactory.FileUtil.isFileNameValid(in.serialLetterName)){
		out.serialLetterName = "letter_"+System.nanoTime();
}

//if desired outputPath is not valid, we take "ivy_RIA_Files"
if(in.outputPath==null || in.outputPath.trim().equalsIgnoreCase("")){
	out.outputPath="ivy_RIA_files";
}' #txt
wr0 f3 @C|.xml '<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<elementInfo>
    <language>
        <name>Check the outputFormat / 
outputPath / outputLetterName</name>
        <nameStyle>55,9
</nameStyle>
    </language>
</elementInfo>
' #txt
wr0 f3 134 212 36 24 22 -18 #rect
wr0 f5 expr out #txt
wr0 f5 152 164 152 212 #arcP
wr0 f8 expr out #txt
wr0 f8 152 236 152 292 #arcP
wr0 f9 @C|.xml '<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<elementInfo>
    <language>
        <name>This callable produces a document with a list of merge fields and 
with the help of a document factory Object.
The Document Factory Object is a Java Object that can parse a document model
that contains mergefields and replace those mergefields by some String Data.

This callable takes some mandatory and some optional input parameters.
Mandatory input Parameters:
-&gt; TemplatePath: this is the path of the template (document model)
-&gt; list of TemplateMergeFields. Each mergefield corresponds to a mergeField in the template.
If no correspondance for a MergeField was found, it will be simply ignored.
Optional input parameters:
-&gt; optionalOutputPath: where to store the created java.io.File. By default &quot;ivy_RIA_files&quot;
-&gt; optionalOutputFormat: by default the first supported one (in general it will be &quot;doc&quot;
-&gt; optionalLetterName: the file name of the letter. By default &quot;letter&quot;+ the nanoTime, 
to be sure the file doesn''t overwrite any other.

It returns a FileOperationMessage Object that contains:
a Type indicating if the operation was successfull,
a message in the Session User language,
a list of java.io.File that were created during the process.

In this callable, just one java.io.File should be created.</name>
        <nameStyle>110,0,7,23
227,7,9
27,0,7,23
237,7,9
26,0,7,23
319,7,9
55,0,7,23
154,7,9
59,0,7,23
</nameStyle>
    </language>
</elementInfo>
' #txt
wr0 f9 44 427 521 362 -255 -176 #rect
wr0 f9 -657956|-1|-16777216 #nodeStyle
wr0 f10 inParamDecl '<CompositeObject data,String optionalOutputpath,String optionalLetterName,String optionalOutputFormat,String templatePath> param;' #txt
wr0 f10 inParamInfo 'data.description=Ivy data class object\: the properties names of the object are the mergefields names. The values of these properties will be written in the document at the place of the corresponding mergefields. 
optionalLetterName.description=Produced document name (default is "letter" + nanotime)
optionalOutputFormat.description=Output format among "doc", "docx", "pdf", "txt", "html". Default is "doc".
optionalOutputpath.description=Output directory path (default is ''%IVY-ROOT-PATH%/ivy_RIA_files/)
templatePath.description=The template path. ' #txt
wr0 f10 inParamTable 'out.data=param.data;
out.outputFormat=param.optionalOutputFormat;
out.outputPath=param.optionalOutputpath;
out.serialLetterName=param.optionalLetterName;
out.templatePath=param.templatePath;
' #txt
wr0 f10 outParamDecl '<ch.ivyteam.ivy.addons.docfactory.FileOperationMessage fileOperationMessage> result;' #txt
wr0 f10 outParamInfo 'fileOperationMessage.description=Result containing a Type indicating if the operation was successfull, a message in the Session User language, a list of java.io.File that were created during the process.' #txt
wr0 f10 outParamTable 'result.fileOperationMessage=in.fileOperationMessage;
' #txt
wr0 f10 callSignature writeDocumentWithOneDataClass(CompositeObject,String,String,String,String) #txt
wr0 f10 @C|.xml '<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<elementInfo>
    <language>
        <name>writeDocumentWithOneDataClass(&#13;
CompositeObject,&#13;
String,String,String,String)</name>
        <nameStyle>78,5
</nameStyle>
        <desc>This callable produces a document with a data (DataClass) and &#13;
with the help of a document factory Object.&#13;
The Document Factory Object is a Java Object that can parse a document model&#13;
that contains mergefields and replace those mergefields by some String Data.&#13;
&#13;
This callable takes some mandatory and some optional input parameters.&#13;
Mandatory input Parameters:&#13;
-&gt; TemplatePath: this is the path of the template (document model)&#13;
-&gt; data . The values of the DataClass fields are going to be used to fill the template and to produce the document.&#13;
The fields of the data have to be named like the fields of the template.&#13;
Optional input parameters:&#13;
-&gt; optionalOutputPath: where to store the created java.io.File. By default "ivy_RIA_files"&#13;
-&gt; optionalOutputFormat: by default the first supported one (in general it will be "doc"&#13;
-&gt; optionalLetterName: the file name of the letter. By default "letter"+ the nanoTime, &#13;
to be sure the file doesn''t overwrite any other.&#13;
&#13;
It returns a FileOperationMessage Object that contains:&#13;
a Type indicating if the operation was successfull,&#13;
a message in the Session User language,&#13;
a list of java.io.File that were created during the process.&#13;
&#13;
In this callable, just one java.io.File should be created.</desc>
    </language>
</elementInfo>
' #txt
wr0 f10 643 51 26 26 -173 -36 #rect
wr0 f10 res:/webContent/icons/doc-factory-logo.png?small #fDecoratorIcon
wr0 f11 @C|.xml '<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<elementInfo>
    <language>
        <name>This callable produces a document with a data (DataClass) and 
with the help of a document factory Object. 

The Document Factory Object is a Java Object that can parse a document model
that contains mergefields and replace those mergefields by some String Data.

This callable takes some mandatory and some optional input parameters.
Mandatory input Parameters:
-&gt; TemplatePath: this is the path of the template (document model)
-&gt; data: A CompositeObject (DataClass). 
The values of the DataClass fields are going to be used to fill the template and to produce the document.
The fields of the data have to be named like the fields of the template. 
If the DataClass Object contains some List of other DataClasses, they will be used in mail merge with nested regions.
Optional input parameters:
-&gt; optionalOutputPath: where to store the created java.io.File. By default &quot;ivy_RIA_files&quot;
-&gt; optionalOutputFormat: by default the first supported one (in general it will be &quot;doc&quot;
-&gt; optionalLetterName: the file name of the letter. By default &quot;letter&quot;+ the nanoTime, 
to be sure the file doesn''t overwrite any other.

It returns a FileOperationMessage Object that contains:
a Type indicating if the operation was successfull,
a message in the Session User language,
a list of java.io.File that were created during the process.

In this callable, just one java.io.File should be created.</name>
        <nameStyle>108,0,7,23
227,7,9
27,0,7,23
407,7,9
26,0,7,23
319,7,9
55,0,7,23
154,7,9
59,0,7,23
</nameStyle>
    </language>
</elementInfo>
' #txt
wr0 f11 593 411 654 410 -322 -200 #rect
wr0 f11 -657956|-1|-16777216 #nodeStyle
wr0 f12 actionTable 'out=in;
' #txt
wr0 f12 actionCode 'import ch.ivyteam.ivy.addons.docfactory.BaseDocFactory;

in.documentFactory= BaseDocFactory.getInstance();' #txt
wr0 f12 @C|.xml '<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<elementInfo>
    <language>
        <name>make the documentFactory 
Object</name>
        <nameStyle>32,7
</nameStyle>
    </language>
</elementInfo>
' #txt
wr0 f12 638 132 36 24 30 -16 #rect
wr0 f13 expr out #txt
wr0 f13 656 77 656 132 #arcP
wr0 f14 actionTable 'out=in;
' #txt
wr0 f14 actionCode '
import ch.ivyteam.ivy.addons.docfactory.FileUtil;

// if desired format not valid, we take the first supportedFormat
if(in.#outputFormat == null || in.outputFormat.trim().equalsIgnoreCase("") 
	|| !in.documentFactory.isFormatSupported(in.outputFormat)){
	if(in.documentFactory.getSupportedFormats().size()>0){
		out.outputFormat=in.documentFactory.getSupportedFormats().get(0);
	}
}

//if desired letter name not valid, we take the name "letter_nanoTime()"
if(in.#serialLetterName == null || in.serialLetterName.trim().equalsIgnoreCase("")
	|| !ch.ivyteam.ivy.addons.docfactory.FileUtil.isFileNameValid(in.serialLetterName)){
		out.serialLetterName = "letter_"+System.nanoTime();
}

//if desired outputPath is not valid, we take "ivy_RIA_Files"
if(in.outputPath==null || in.outputPath.trim().equalsIgnoreCase("")){
	out.outputPath="ivy_RIA_files";
}

' #txt
wr0 f14 @C|.xml '<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<elementInfo>
    <language>
        <name>Check the outputFormat / 
outputPath / outputLetterName
</name>
        <nameStyle>56,7,9
</nameStyle>
    </language>
</elementInfo>
' #txt
wr0 f14 638 196 36 24 22 -18 #rect
wr0 f15 expr out #txt
wr0 f15 656 156 656 196 #arcP
wr0 f16 actionTable 'out=in;
' #txt
wr0 f16 actionCode 'import ch.ivyteam.ivy.addons.docfactory.DocumentTemplate;

out.documentTemplate = new DocumentTemplate(in.templatePath,in.outputPath, in.serialLetterName,in.outputFormat,in.data);' #txt
wr0 f16 @C|.xml '<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<elementInfo>
    <language>
        <name>build DocumentTemplate</name>
        <nameStyle>22,7
</nameStyle>
    </language>
</elementInfo>
' #txt
wr0 f16 638 236 36 24 20 -2 #rect
wr0 f17 expr out #txt
wr0 f17 656 220 656 236 #arcP
wr0 f18 actionTable 'out=in;
' #txt
wr0 f18 actionCode out.fileOperationMessage=in.documentFactory.generateDocument(in.documentTemplate); #txt
wr0 f18 @C|.xml '<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<elementInfo>
    <language>
        <name>write the serial letter</name>
        <nameStyle>23,7
</nameStyle>
    </language>
</elementInfo>
' #txt
wr0 f18 638 284 36 24 20 -2 #rect
wr0 f19 expr out #txt
wr0 f19 656 260 656 284 #arcP
wr0 f20 643 363 26 26 14 0 #rect
wr0 f20 res:/webContent/icons/doc-factory-logo.png?small #fDecoratorIcon
wr0 f21 expr out #txt
wr0 f21 656 308 656 363 #arcP
wr0 f22 inParamDecl '<List<ch.ivyteam.ivy.addons.docfactory.TemplateMergeField> listOfTemplateMergeFields,String optionalOutputpath,String optionalLetterName,String optionalOutputFormat,String templatePath,List<String> tableNamesList,List<List<CompositeObject>> datasForTables> param;' #txt
wr0 f22 inParamInfo 'datasForTables.description=Data for filling the tables. Each list of composite object is used in the corresponding (by the index) table name.
listOfTemplateMergeFields.description=List of template mergefields (key/values) for the simple merge fields.
optionalLetterName.description=Produced document name (default is "letter" + nanotime)
optionalOutputFormat.description=Output format among "doc", "docx", "pdf", "txt", "html". Default is "doc".
optionalOutputpath.description=Output directory path (default is ''%IVY-ROOT-PATH%/ivy_RIA_files/)
tableNamesList.description=The list of the tables names (mail merge regions) present in the template
templatePath.description=The template path. ' #txt
wr0 f22 inParamTable 'out.ListOfCompositeObjectsToFillTheTables=param.datasForTables;
out.mergeFieldsList=param.listOfTemplateMergeFields;
out.outputFormat=param.optionalOutputFormat;
out.outputPath=param.optionalOutputpath;
out.serialLetterName=param.optionalLetterName;
out.tablesNamesList=param.tableNamesList;
out.templatePath=param.templatePath;
' #txt
wr0 f22 outParamDecl '<ch.ivyteam.ivy.addons.docfactory.FileOperationMessage fileOperationMessage> result;' #txt
wr0 f22 outParamInfo 'fileOperationMessage.description=Result containing a Type indicating if the operation was successfull, a message in the Session User language, a list of java.io.File that were created during the process.' #txt
wr0 f22 outParamTable 'result.fileOperationMessage=in.fileOperationMessage;
' #txt
wr0 f22 callSignature writeDocumentWithMailMergeTable(List<ch.ivyteam.ivy.addons.docfactory.TemplateMergeField>,String,String,String,String,List<String>,List<List<CompositeObject>>) #txt
wr0 f22 @C|.xml '<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<elementInfo>
    <language>
        <name>writeDocumentWithMailMergeTable(
List&lt;TemplateMergeField&gt;,
String,String,String,String,
List&lt;String&gt;,List&lt;List&lt;CompositeObject&gt;&gt;)</name>
        <nameStyle>129,5,7
</nameStyle>
        <desc>Produces a document with a list of merge fields and &#13;
with the help of a document factory Object. The Merge Mail With Regions is supported.&#13;
The Document Factory Object is a Java Object that can parse a document model&#13;
that contains mergefields and replace those mergefields by some String Data.&#13;
&#13;
A Mail Merge Region is a Table in the template which rows are going to be automatically filled with some data.&#13;
Each table in the template has a name and is set by a Start Mergefield(TableStart:nameOfTheTable).&#13;
To be able to perform this operation, one may provide the list of the tables names, the merge fields names for each table and the data (rows).&#13;
If there is no table in the given template, or no match between your data and the tables names/fieldsnames, these callables just ignore the tables&#13;
and perform normal mail merge.&#13;
&#13;
This callable takes some mandatory and some optional input parameters.&#13;
Mandatory input Parameters:&#13;
-&gt; TemplatePath: this is the path of the template (document model)&#13;
-&gt; list of TemplateMergeFields. Each mergefield corresponds to a mergeField in the template.&#13;
If no correspondance for a MergeField was found, it will be simply ignored.&#13;
&#13;
Optional input parameters:&#13;
-&gt; optionalOutputPath: where to store the created java.io.File. By default "ivy_RIA_files"&#13;
-&gt; optionalOutputFormat: by default the first supported one (in general it will be "doc"&#13;
-&gt; optionalLetterName: the file name of the letter. By default "letter"+ the nanoTime, &#13;
to be sure the file doesn''t overwrite any other.&#13;
-&gt; Data for filling some tables: list of table names and a List of List of Composite Objects. &#13;
Each list of table names is filled with the corresponding index of the List of Composite objects.&#13;
&#13;
It returns a FileOperationMessage Object that contains:&#13;
a Type indicating if the operation was successfull,&#13;
a message in the Session User language,&#13;
a list of java.io.File that were created during the process.&#13;
In this callable just one java.io.File is created. So the list of created File contains only one File in case of success.</desc>
    </language>
</elementInfo>
' #txt
wr0 f22 1459 59 26 26 16 -36 #rect
wr0 f22 res:/webContent/icons/doc-factory-logo.png?small #fDecoratorIcon
wr0 f23 actionTable 'out=in;
' #txt
wr0 f23 actionCode 'import java.util.HashMap;
HashMap map = new HashMap();

if(in.tablesNamesList.size()>0 && 
in.ListOfCompositeObjectsToFillTheTables.size()==in.tablesNamesList.size()){
	int i=0;
	for(String s : in.tablesNamesList)
	{
		map.put(s,in.ListOfCompositeObjectsToFillTheTables.get(i));
		i++;
	}
	
}
try{
	out.fileOperationMessage = 
	in.documentFactory.generateDocumentWithRegions(in.templatePath,in.serialLetterName,in.outputPath,in.outputFormat,in.mergeFieldsList,map);
}catch (Throwable t){
	ivy.log.error(t.getMessage(),t);
}

' #txt
wr0 f23 @C|.xml '<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<elementInfo>
    <language>
        <name>make the hash map for the merge mail with regions
and write the serialLetter</name>
        <nameStyle>50,7,9
4,7,9
22,7,9
</nameStyle>
    </language>
</elementInfo>
' #txt
wr0 f23 1454 292 36 24 22 -9 #rect
wr0 f24 actionTable 'out=in;
' #txt
wr0 f24 actionCode 'import ch.ivyteam.ivy.addons.docfactory.FileUtil;

// if desired format not valid, we take the first supportedFormat
if(in.#outputFormat == null || in.outputFormat.trim().equalsIgnoreCase("") 
	|| !in.documentFactory.isFormatSupported(in.outputFormat)){
	if(in.documentFactory.getSupportedFormats().size()>0){
		out.outputFormat=in.documentFactory.getSupportedFormats().get(0);
	}
}

//if desired letter name not valid, we take the name "letter_nanoTime()"
if(in.#serialLetterName == null || in.serialLetterName.trim().equalsIgnoreCase("")
	|| !ch.ivyteam.ivy.addons.docfactory.FileUtil.isFileNameValid(in.serialLetterName)){
		out.serialLetterName = "letter_"+System.nanoTime();
}

//if desired outputPath is not valid, we take "ivy_RIA_Files"
if(in.outputPath==null || in.outputPath.trim().equalsIgnoreCase("")){
	out.outputPath="ivy_RIA_files";
}

' #txt
wr0 f24 @C|.xml '<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<elementInfo>
    <language>
        <name>Check the outputFormat / 
outputPath / outputLetterName </name>
        <nameStyle>56,7,9
</nameStyle>
    </language>
</elementInfo>
' #txt
wr0 f24 1454 212 36 24 22 -18 #rect
wr0 f25 actionTable 'out=in;
' #txt
wr0 f25 actionCode 'import ch.ivyteam.ivy.addons.docfactory.BaseDocFactory;
in.documentFactory= BaseDocFactory.getInstance();' #txt
wr0 f25 @C|.xml '<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<elementInfo>
    <language>
        <name>make the documentFactory 
Object</name>
        <nameStyle>32,7,9
</nameStyle>
    </language>
</elementInfo>
' #txt
wr0 f25 1454 140 36 24 22 -15 #rect
wr0 f26 expr out #txt
wr0 f26 1472 164 1472 212 #arcP
wr0 f27 expr out #txt
wr0 f27 1472 236 1472 292 #arcP
wr0 f28 expr out #txt
wr0 f28 1472 85 1472 140 #arcP
wr0 f29 1459 363 26 26 14 0 #rect
wr0 f29 res:/webContent/icons/doc-factory-logo.png?small #fDecoratorIcon
wr0 f30 expr out #txt
wr0 f30 1472 316 1472 363 #arcP
wr0 f31 inParamDecl '<List<ch.ivyteam.ivy.addons.docfactory.TemplateMergeField> listOfTemplateMergeFields,String optionalOutputpath,String optionalLetterName,String optionalOutputFormat,String templatePath,List<String> tableNamesList,List<Recordset> recordsetsList> param;' #txt
wr0 f31 inParamInfo 'listOfTemplateMergeFields.description=List of template mergefields (key/values) for the simple merge fields.
optionalLetterName.description=Produced document name (default is "letter" + nanotime)
optionalOutputFormat.description=Output format among "doc", "docx", "pdf", "txt", "html". Default is "doc".
optionalOutputpath.description=Output directory path (default is ''%IVY-ROOT-PATH%/ivy_RIA_files/)
recordsetsList.description=Data for filling some tables (merge region). Each field of the recordset is seen as a mergefield, and each record is a row of data.
tableNamesList.description=The list of the tables names (mail merge regions) present in the template
templatePath.description=The template path. ' #txt
wr0 f31 inParamTable 'out.ListOfRecordsets=param.recordsetsList;
out.mergeFieldsList=param.listOfTemplateMergeFields;
out.outputFormat=param.optionalOutputFormat;
out.outputPath=param.optionalOutputpath;
out.serialLetterName=param.optionalLetterName;
out.tablesNamesList=param.tableNamesList;
out.templatePath=param.templatePath;
' #txt
wr0 f31 outParamDecl '<ch.ivyteam.ivy.addons.docfactory.FileOperationMessage fileOperationMessage> result;' #txt
wr0 f31 outParamInfo 'fileOperationMessage.description=Result containing a Type indicating if the operation was successfull, a message in the Session User language, a list of java.io.File that were created during the process.' #txt
wr0 f31 outParamTable 'result.fileOperationMessage=in.fileOperationMessage;
' #txt
wr0 f31 callSignature writeDocumentWithMailMergeTable(List<ch.ivyteam.ivy.addons.docfactory.TemplateMergeField>,String,String,String,String,List<String>,List<Recordset>) #txt
wr0 f31 @C|.xml '<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<elementInfo>
    <language>
        <name>writeDocumentWithMailMergeTable(
List&lt;TemplateMergeField&gt;,
String,String,String,String,
List&lt;String&gt;,List&lt;Recordset&gt;)</name>
        <nameStyle>117,5,7
</nameStyle>
        <desc>Produces a document with a list of merge fields and &#13;
with the help of a document factory Object. The Merge Mail With Regions is supported.&#13;
The Document Factory Object is a Java Object that can parse a document model&#13;
that contains mergefields and replace those mergefields by some String Data.&#13;
&#13;
A Mail Merge Region is a Table in the template which rows are going to be automatically filled with some data.&#13;
Each table in the template has a name and is set by a Start Mergefield(TableStart:nameOfTheTable).&#13;
To be able to perform this operation, one may provide the list of the tables names, the merge fields names for each table and the data (rows).&#13;
If there is no table in the given template, or no match between your data and the tables names/fieldsnames, these callables just ignore the tables&#13;
and perform normal mail merge.&#13;
&#13;
This callable takes some mandatory and some optional input parameters.&#13;
Mandatory input Parameters:&#13;
-&gt; TemplatePath: this is the path of the template (document model)&#13;
-&gt; list of TemplateMergeFields. Each mergefield corresponds to a mergeField in the template.&#13;
If no correspondance for a MergeField was found, it will be simply ignored.&#13;
&#13;
Optional input parameters:&#13;
-&gt; optionalOutputPath: where to store the created java.io.File. By default "ivy_RIA_files"&#13;
-&gt; optionalOutputFormat: by default the first supported one (in general it will be "doc"&#13;
-&gt; optionalLetterName: the file name of the letter. By default "letter"+ the nanoTime, &#13;
to be sure the file doesn''t overwrite any other.&#13;
-&gt; Data for filling some tables: list of table names and a List of Recordsets. &#13;
Each list of table names is filled with the corresponding RecordSet (table name at index x corresponds to the recordset at the same index in the list).&#13;
&#13;
It returns a FileOperationMessage Object that contains:&#13;
a Type indicating if the operation was successfull,&#13;
a message in the Session User language,&#13;
a list of java.io.File that were created during the process.&#13;
In this callable just one java.io.File is created. So the list of created File contains only one File in case of success.</desc>
    </language>
</elementInfo>
' #txt
wr0 f31 2051 51 26 26 17 -31 #rect
wr0 f31 res:/webContent/icons/doc-factory-logo.png?small #fDecoratorIcon
wr0 f32 actionTable 'out=in;
' #txt
wr0 f32 actionCode 'import ch.ivyteam.ivy.addons.docfactory.BaseDocFactory;
in.documentFactory= BaseDocFactory.getInstance();' #txt
wr0 f32 @C|.xml '<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<elementInfo>
    <language>
        <name>make the documentFactory 
Object</name>
        <nameStyle>32,7,9
</nameStyle>
    </language>
</elementInfo>
' #txt
wr0 f32 2046 132 36 24 22 -15 #rect
wr0 f33 actionTable 'out=in;
' #txt
wr0 f33 actionCode 'import java.util.Hashtable;
Hashtable htable = new Hashtable();

if(in.tablesNamesList.size()>0 && 
	in.ListOfRecordsets.size()==in.tablesNamesList.size()){
	int i=0;
	for(String s : in.tablesNamesList)
	{
		htable.put(s,in.ListOfRecordsets.get(i));
		i++;
	}
}
try{
	out.fileOperationMessage = 
	in.documentFactory.generateDocumentWithRegions(in.templatePath,in.serialLetterName,in.outputPath,in.outputFormat,in.mergeFieldsList,htable);
}catch (Throwable t){
	ivy.log.error(t.getMessage(),t);
}

' #txt
wr0 f33 @C|.xml '<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<elementInfo>
    <language>
        <name>make the hash table for the merge mail with regions
and write the serialLetter</name>
        <nameStyle>52,7,9
4,7,9
22,7,9
</nameStyle>
    </language>
</elementInfo>
' #txt
wr0 f33 2046 284 36 24 22 -9 #rect
wr0 f34 actionTable 'out=in;
' #txt
wr0 f34 actionCode 'import ch.ivyteam.ivy.addons.docfactory.FileUtil;

// if desired format not valid, we take the first supportedFormat
if(in.#outputFormat == null || in.outputFormat.trim().equalsIgnoreCase("") 
	|| !in.documentFactory.isFormatSupported(in.outputFormat)){
	if(in.documentFactory.getSupportedFormats().size()>0){
		out.outputFormat=in.documentFactory.getSupportedFormats().get(0);
	}
}

//if desired letter name not valid, we take the name "letter_nanoTime()"
if(in.#serialLetterName == null || in.serialLetterName.trim().equalsIgnoreCase("")
	|| !ch.ivyteam.ivy.addons.docfactory.FileUtil.isFileNameValid(in.serialLetterName)){
		out.serialLetterName = "letter_"+System.nanoTime();
}

//if desired outputPath is not valid, we take "ivy_RIA_Files"
if(in.outputPath==null || in.outputPath.trim().equalsIgnoreCase("")){
	out.outputPath="ivy_RIA_files";
}

' #txt
wr0 f34 @C|.xml '<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<elementInfo>
    <language>
        <name>Check the outputFormat / 
outputPath / outputLetterName </name>
        <nameStyle>56,7,9
</nameStyle>
    </language>
</elementInfo>
' #txt
wr0 f34 2046 204 36 24 22 -18 #rect
wr0 f35 expr out #txt
wr0 f35 2064 156 2064 204 #arcP
wr0 f36 expr out #txt
wr0 f36 2064 228 2064 284 #arcP
wr0 f37 expr out #txt
wr0 f37 2064 77 2064 132 #arcP
wr0 f38 2051 363 26 26 14 0 #rect
wr0 f38 res:/webContent/icons/doc-factory-logo.png?small #fDecoratorIcon
wr0 f39 expr out #txt
wr0 f39 2064 308 2064 363 #arcP
wr0 f40 inParamDecl '<List<ch.ivyteam.ivy.addons.docfactory.TemplateMergeField> listOfTemplateMergeFields,String optionalOutputpath,String optionalLetterName,String optionalOutputFormat,String templatePath,List<String> tableNamesList,List<List<String>> tablesFieldsNames,List<List<List<Object>>> tablesRowsValues> param;' #txt
wr0 f40 inParamInfo 'listOfTemplateMergeFields.description=List of template mergefields (key/values) for the simple merge fields.
optionalLetterName.description=Produced document name (default is "letter" + nanotime)
optionalOutputFormat.description=Output format among "doc", "docx", "pdf", "txt", "html". Default is "doc".
optionalOutputpath.description=Output directory path (default is ''%IVY-ROOT-PATH%/ivy_RIA_files/)
tableNamesList.description=The list of the tables names (mail merge regions) present in the template
tablesFieldsNames.description=The list of the tables names merge fields names. Each table having a corresponding (same index) List of mergefields.
tablesRowsValues.description=Data for filling the tables (merge regions)\: each table mergefield has a corresponding List<List of values>>
templatePath.description=The template path. ' #txt
wr0 f40 inParamTable 'out.ListOfTableFieldsNames=param.tablesFieldsNames;
out.ListOfTablesRows=param.tablesRowsValues;
out.mergeFieldsList=param.listOfTemplateMergeFields;
out.outputFormat=param.optionalOutputFormat;
out.outputPath=param.optionalOutputpath;
out.serialLetterName=param.optionalLetterName;
out.tablesNamesList=param.tableNamesList;
out.templatePath=param.templatePath;
' #txt
wr0 f40 outParamDecl '<ch.ivyteam.ivy.addons.docfactory.FileOperationMessage fileOperationMessage> result;' #txt
wr0 f40 outParamInfo 'fileOperationMessage.description=Result containing a Type indicating if the operation was successfull, a message in the Session User language, a list of java.io.File that were created during the process.' #txt
wr0 f40 outParamTable 'result.fileOperationMessage=in.fileOperationMessage;
' #txt
wr0 f40 callSignature writeDocumentWithMailMergeTable(List<ch.ivyteam.ivy.addons.docfactory.TemplateMergeField>,String,String,String,String,List<String>,List<List<String>>,List<List<List<Object>>>) #txt
wr0 f40 @C|.xml '<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<elementInfo>
    <language>
        <name>writeDocumentWithMailMergeTable(
List&lt;TemplateMergeField&gt;,
String,String,String,String,
List&lt;String&gt;,List&lt;List&lt;String&gt;&gt;,
List&lt;List&lt;List&gt;&gt;)</name>
        <nameStyle>138,5,7
</nameStyle>
        <desc>Produces a document with a list of merge fields and &#13;
with the help of a document factory Object. The Merge Mail With Regions is supported.&#13;
The Document Factory Object is a Java Object that can parse a document model&#13;
that contains mergefields and replace those mergefields by some String Data.&#13;
&#13;
A Mail Merge Region is a Table in the template whose rows are going to be automatically filled with some data.&#13;
To be able to perform this operation, one may provide the list of the tables names, the merge fields names for each table and the data (rows).&#13;
If you want to fill some tables, the list of the tables names have to be provided in all the callables Starts. The tables are named in the template.&#13;
Then the fields names and the data can be provided in several ways:&#13;
	. Lists of DataClasses objects (CompositeObjects): each attribute name will be seen as a mergeField name, each object is a row in a table.&#13;
	. List of Recordsets: each field of the recordset is seen as a mergefield, and each record is a row of data.&#13;
	. For each table you provide a list of fields'' names and the rows are encapsulated into list of Objects.&#13;
If there is no table in the given template, or no match between your data and the tables names/fieldsnames, these callables just ignore the tables&#13;
and perform normal mail merge.&#13;
&#13;
This callable takes some mandatory and some optional input parameters.&#13;
Mandatory input Parameters:&#13;
-&gt; TemplatePath: this is the path of the template (document model)&#13;
-&gt; list of TemplateMergeFields. Each mergefield corresponds to a mergeField in the template.&#13;
If no correspondance for a MergeField was found, it will be simply ignored.&#13;
Optional input parameters:&#13;
-&gt; optionalOutputPath: where to store the created java.io.File. By default "ivy_RIA_files"&#13;
-&gt; optionalOutputFormat: by default the first supported one (in general it will be "doc"&#13;
-&gt; optionalLetterName: the file name of the letter. By default "letter"+ the nanoTime, &#13;
to be sure the file doesn''t overwrite any other.&#13;
-&gt; Data for filling some tables (see description above about Mail Merge Regions) -&gt; HERE For each table you provide a list of fields'' names and the rows are encapsulated into list of Objects.&#13;
&#13;
It returns a FileOperationMessage Object that contains:&#13;
a Type indicating if the operation was successfull,&#13;
a message in the Session User language,&#13;
a list of java.io.File that were created during the process. Just one java.io.File should be created.</desc>
    </language>
</elementInfo>
' #txt
wr0 f40 2427 51 26 26 19 -35 #rect
wr0 f40 res:/webContent/icons/doc-factory-logo.png?small #fDecoratorIcon
wr0 f41 actionTable 'out=in;
' #txt
wr0 f41 actionCode 'import ch.ivyteam.ivy.addons.docfactory.FileUtil;

// if desired format not valid, we take the first supportedFormat
if(in.#outputFormat == null || in.outputFormat.trim().equalsIgnoreCase("") 
	|| !in.documentFactory.isFormatSupported(in.outputFormat)){
	if(in.documentFactory.getSupportedFormats().size()>0){
		out.outputFormat=in.documentFactory.getSupportedFormats().get(0);
	}
}

//if desired letter name not valid, we take the name "letter_nanoTime()"
if(in.#serialLetterName == null || in.serialLetterName.trim().equalsIgnoreCase("")
	|| !ch.ivyteam.ivy.addons.docfactory.FileUtil.isFileNameValid(in.serialLetterName)){
		out.serialLetterName = "letter_"+System.nanoTime();
}

//if desired outputPath is not valid, we take "ivy_RIA_Files"
if(in.outputPath==null || in.outputPath.trim().equalsIgnoreCase("")){
	out.outputPath="ivy_RIA_files";
}

' #txt
wr0 f41 @C|.xml '<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<elementInfo>
    <language>
        <name>Check the outputFormat / 
outputPath / outputLetterName </name>
        <nameStyle>56,7,9
</nameStyle>
    </language>
</elementInfo>
' #txt
wr0 f41 2422 212 36 24 22 -18 #rect
wr0 f42 actionTable 'out=in;
' #txt
wr0 f42 actionCode 'import ch.ivyteam.ivy.addons.docfactory.BaseDocFactory;
in.documentFactory= BaseDocFactory.getInstance();' #txt
wr0 f42 @C|.xml '<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<elementInfo>
    <language>
        <name>make the documentFactory 
Object</name>
        <nameStyle>32,7,9
</nameStyle>
    </language>
</elementInfo>
' #txt
wr0 f42 2422 140 36 24 22 -15 #rect
wr0 f43 actionTable 'out=in;
' #txt
wr0 f43 actionCode '
try{
	out.fileOperationMessage = 
	in.documentFactory.generateDocumentWithRegions(in.templatePath,in.serialLetterName,in.outputPath,in.outputFormat,in.mergeFieldsList,in.tablesNamesList,in.ListOfTableFieldsNames,in.ListOfTablesRows);
}catch (Throwable t){
	ivy.log.error(t.getMessage(),t);
}

' #txt
wr0 f43 @C|.xml '<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<elementInfo>
    <language>
        <name>write the serialLetter</name>
        <nameStyle>22,7,9
</nameStyle>
    </language>
</elementInfo>
' #txt
wr0 f43 2422 292 36 24 22 -9 #rect
wr0 f44 expr out #txt
wr0 f44 2440 164 2440 212 #arcP
wr0 f45 expr out #txt
wr0 f45 2440 236 2440 292 #arcP
wr0 f46 expr out #txt
wr0 f46 2440 77 2440 140 #arcP
wr0 f47 2427 363 26 26 14 0 #rect
wr0 f47 res:/webContent/icons/doc-factory-logo.png?small #fDecoratorIcon
wr0 f48 expr out #txt
wr0 f48 2440 316 2440 363 #arcP
wr0 f49 @C|.xml '<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<elementInfo>
    <language>
        <name>These callables produce a document with a list of merge fields and 
with the help of a document factory Object. The Merge Mail With Regions is supported.
The Document Factory Object is a Java Object that can parse a document model
that contains mergefields and replace those mergefields by some String Data.

A Mail Merge Region is a Table in the template whose rows are going to be automatically filled with some data.
To be able to perform this operation, one may provide the list of the tables names, the merge fields names for each table and the data (rows).
The Names of the tables in the template are given by a Start Mergefield(TableStart:nameOfTheTable).
If you want to fill some tables, the list of the tables names have to be provided in all the callables Starts. 
The fields names and the data can be provided in several ways:
	. Lists of DataClasses objects (CompositeObjects): each attribute name will be seen as a mergeField name, each object is a row in a table.
	. List of Recordsets: each field of the recordset is seen as a mergefield, and each record is a row of data.
	. For each table you provide a list of fields'' names and the rows are encapsulated into list of Objects.
If there is no table in the given template, or no match between your data and the tables names/fieldsnames, these callables just ignore the tables
and perform normal mail merge.

This callable takes some mandatory and some optional input parameters.
Mandatory input Parameters:
-&gt; TemplatePath: this is the path of the template (document model)
-&gt; list of TemplateMergeFields. Each mergefield corresponds to a mergeField in the template.
If no correspondance for a MergeField was found, it will be simply ignored.
-&gt; Or Composite Object whose attributes are going to be mapped with the template''s mergefields.

Optional input parameters:
-&gt; optionalOutputPath: where to store the created java.io.File. By default &quot;ivy_RIA_files&quot;
-&gt; optionalOutputFormat: by default the first supported one (in general it will be &quot;doc&quot;
-&gt; optionalLetterName: the file name of the letter. By default &quot;letter&quot;+ the nanoTime, 
to be sure the file doesn''t overwrite any other.
-&gt; Data for filling some tables (see description above about Mail Merge Regions)

It returns a FileOperationMessage Object that contains:
a Type indicating if the operation was successfull,
a message in the Session User language,
a list of java.io.File that were created during the process.

In these callables, just one java.io.File should be created.</name>
        <nameStyle>153,0,7,23
156,7,9
337,7,21
14,1,2,7,21
712,7,21
72,7,9
27,0,7,23
68,7,9
265,7,15
1,7,9
26,0,7,23
400,7,9
55,0,7,23
154,7,9
61,0,7,23
</nameStyle>
    </language>
</elementInfo>
' #txt
wr0 f49 1350 412 1188 585 -417 -288 #rect
wr0 f49 -657956|-1|-16777216 #nodeStyle
wr0 f50 inParamDecl '<CompositeObject data,String optionalOutputpath,String optionalLetterName,String optionalOutputFormat,String templatePath,List<String> tableNamesList,List<List<CompositeObject>> datasForTables> param;' #txt
wr0 f50 inParamInfo 'data.description=Ivy data class object used for the normal merge fields\: the properties names of the object are the mergefields names. The values of these properties will be written in the document at the place of the corresponding mergefields. 
datasForTables.description=Data for filling the tables. Each list of composite object is used in the corresponding (by the index) table name.
optionalLetterName.description=Produced document name (default is "letter" + nanotime)
optionalOutputFormat.description=Output format among "doc", "docx", "pdf", "txt", "html". Default is "doc".
optionalOutputpath.description=Output directory path (default is ''%IVY-ROOT-PATH%/ivy_RIA_files/)
tableNamesList.description=The list of the tables names (mail merge regions) present in the template
templatePath.description=The template path. ' #txt
wr0 f50 inParamTable 'out.data=param.data;
out.ListOfCompositeObjectsToFillTheTables=param.datasForTables;
out.outputFormat=param.optionalOutputFormat;
out.outputPath=param.optionalOutputpath;
out.serialLetterName=param.optionalLetterName;
out.tablesNamesList=param.tableNamesList;
out.templatePath=param.templatePath;
' #txt
wr0 f50 outParamDecl '<ch.ivyteam.ivy.addons.docfactory.FileOperationMessage fileOperationMessage> result;' #txt
wr0 f50 outParamInfo 'fileOperationMessage.description=Result containing a Type indicating if the operation was successfull, a message in the Session User language, a list of java.io.File that were created during the process.' #txt
wr0 f50 outParamTable 'result.fileOperationMessage=in.fileOperationMessage;
' #txt
wr0 f50 callSignature writeDocumentWithMailMergeTable(CompositeObject,String,String,String,String,List<String>,List<List<CompositeObject>>) #txt
wr0 f50 @C|.xml '<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<elementInfo>
    <language>
        <name>writeDocumentWithMailMergeTable(
CompositeObject,
String,String,String,String,
List&lt;String&gt;,List&lt;List&lt;CompositeObject&gt;&gt;)</name>
        <nameStyle>120,5,7
</nameStyle>
        <desc>Produces a document with a list of merge fields and &#13;
with the help of a document factory Object. The Merge Mail With Regions is supported.&#13;
The Document Factory Object is a Java Object that can parse a document model&#13;
that contains mergefields and replace those mergefields by some String Data.&#13;
&#13;
A Mail Merge Region is a Table in the template which rows are going to be automatically filled with some data.&#13;
Each table in the template has a name and is set by a Start Mergefield(TableStart:nameOfTheTable).&#13;
To be able to perform this operation, one may provide the list of the tables names, the merge fields names for each table and the data (rows).&#13;
If there is no table in the given template, or no match between your data and the tables names/fieldsnames, these callables just ignore the tables&#13;
and perform normal mail merge.&#13;
&#13;
This callable takes some mandatory and some optional input parameters.&#13;
Mandatory input Parameters:&#13;
-&gt; TemplatePath: this is the path of the template (document model)&#13;
-&gt; Composite Object whose attributes are going to be mapped with the template''s simple mergefields.&#13;
&#13;
Optional input parameters:&#13;
-&gt; optionalOutputPath: where to store the created java.io.File. By default "ivy_RIA_files"&#13;
-&gt; optionalOutputFormat: by default the first supported one (in general it will be "doc"&#13;
-&gt; optionalLetterName: the file name of the letter. By default "letter"+ the nanoTime, &#13;
to be sure the file doesn''t overwrite any other.&#13;
-&gt; Data for filling some tables: list of table names and a List of List of Composite Objects. &#13;
Each list of table names is filled with the corresponding index of the List of Composite objects.&#13;
&#13;
It returns a FileOperationMessage Object that contains:&#13;
a Type indicating if the operation was successfull,&#13;
a message in the Session User language,&#13;
a list of java.io.File that were created during the process.&#13;
In this callable just one java.io.File is created. So the list of created File contains only one File in case of success.</desc>
    </language>
</elementInfo>
' #txt
wr0 f50 1347 59 26 26 -246 -48 #rect
wr0 f50 res:/webContent/icons/doc-factory-logo.png?small #fDecoratorIcon
wr0 f51 actionTable 'out=in;
' #txt
wr0 f51 actionCode 'import ch.ivyteam.ivy.addons.docfactory.DocumentTemplate;
import java.util.HashMap;
HashMap map = new HashMap();

if(in.tablesNamesList.size()>0 && 
in.ListOfCompositeObjectsToFillTheTables.size()==in.tablesNamesList.size()){
	int i=0;
	for(String s : in.tablesNamesList)
	{
		map.put(s,in.ListOfCompositeObjectsToFillTheTables.get(i));
		i++;
	}
	
}
out.documentTemplate = new DocumentTemplate(in.templatePath,in.outputPath, in.serialLetterName,in.outputFormat,in.data,map);' #txt
wr0 f51 @C|.xml '<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<elementInfo>
    <language>
        <name>build DocumentTemplate</name>
        <nameStyle>22,7
</nameStyle>
    </language>
</elementInfo>
' #txt
wr0 f51 1342 236 36 24 -163 -11 #rect
wr0 f52 actionTable 'out=in;
' #txt
wr0 f52 actionCode '
import ch.ivyteam.ivy.addons.docfactory.FileUtil;

// if desired format not valid, we take the first supportedFormat
if(in.#outputFormat == null || in.outputFormat.trim().equalsIgnoreCase("") 
	|| !in.documentFactory.isFormatSupported(in.outputFormat)){
	if(in.documentFactory.getSupportedFormats().size()>0){
		out.outputFormat=in.documentFactory.getSupportedFormats().get(0);
	}
}

//if desired letter name not valid, we take the name "letter_nanoTime()"
if(in.#serialLetterName == null || in.serialLetterName.trim().equalsIgnoreCase("")
	|| !ch.ivyteam.ivy.addons.docfactory.FileUtil.isFileNameValid(in.serialLetterName)){
		out.serialLetterName = "letter_"+System.nanoTime();
}

//if desired outputPath is not valid, we take "ivy_RIA_Files"
if(in.outputPath==null || in.outputPath.trim().equalsIgnoreCase("")){
	out.outputPath="ivy_RIA_files";
}

' #txt
wr0 f52 @C|.xml '<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<elementInfo>
    <language>
        <name>Check the outputFormat / 
outputPath / outputLetterName
</name>
        <nameStyle>56,7,9
</nameStyle>
    </language>
</elementInfo>
' #txt
wr0 f52 1342 196 36 24 -187 -26 #rect
wr0 f53 actionTable 'out=in;
' #txt
wr0 f53 actionCode 'import ch.ivyteam.ivy.addons.docfactory.BaseDocFactory;

in.documentFactory= BaseDocFactory.getInstance();' #txt
wr0 f53 @C|.xml '<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<elementInfo>
    <language>
        <name>make the documentFactory 
Object</name>
        <nameStyle>32,7
</nameStyle>
    </language>
</elementInfo>
' #txt
wr0 f53 1342 148 36 24 -175 -18 #rect
wr0 f54 actionTable 'out=in;
' #txt
wr0 f54 actionCode out.fileOperationMessage=in.documentFactory.generateDocument(in.documentTemplate); #txt
wr0 f54 @C|.xml '<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<elementInfo>
    <language>
        <name>write the serial letter</name>
        <nameStyle>23,7
</nameStyle>
    </language>
</elementInfo>
' #txt
wr0 f54 1342 300 36 24 -139 -9 #rect
wr0 f55 expr out #txt
wr0 f55 1360 172 1360 196 #arcP
wr0 f56 expr out #txt
wr0 f56 1360 220 1360 236 #arcP
wr0 f57 expr out #txt
wr0 f57 1360 260 1360 300 #arcP
wr0 f58 expr out #txt
wr0 f58 1360 85 1360 148 #arcP
wr0 f59 1347 363 26 26 14 0 #rect
wr0 f59 res:/webContent/icons/doc-factory-logo.png?small #fDecoratorIcon
wr0 f60 expr out #txt
wr0 f60 1360 324 1360 363 #arcP
wr0 f61 inParamDecl '<CompositeObject data,String optionalOutputpath,String optionalLetterName,String optionalOutputFormat,String templatePath,List<String> tableNamesList,List<Recordset> recordsetsList> param;' #txt
wr0 f61 inParamInfo 'data.description=Ivy data class object used for the normal merge fields\: the properties names of the object are the mergefields names. The values of these properties will be written in the document at the place of the corresponding mergefields. 
optionalLetterName.description=Produced document name (default is "letter" + nanotime)
optionalOutputFormat.description=Output format among "doc", "docx", "pdf", "txt", "html". Default is "doc".
optionalOutputpath.description=Output directory path (default is ''%IVY-ROOT-PATH%/ivy_RIA_files/)
recordsetsList.description=Data for filling some tables (merge region). Each field of the recordset is seen as a mergefield, and each record is a row of data.
tableNamesList.description=The list of the tables names (mail merge regions) present in the template
templatePath.description=The template path. ' #txt
wr0 f61 inParamTable 'out.data=param.data;
out.ListOfRecordsets=param.recordsetsList;
out.outputFormat=param.optionalOutputFormat;
out.outputPath=param.optionalOutputpath;
out.serialLetterName=param.optionalLetterName;
out.tablesNamesList=param.tableNamesList;
out.templatePath=param.templatePath;
' #txt
wr0 f61 outParamDecl '<ch.ivyteam.ivy.addons.docfactory.FileOperationMessage fileOperationMessage> result;' #txt
wr0 f61 outParamInfo 'fileOperationMessage.description=Result containing a Type indicating if the operation was successfull, a message in the Session User language, a list of java.io.File that were created during the process.' #txt
wr0 f61 callSignature writeDocumentWithMailMergeTable(CompositeObject,String,String,String,String,List<String>,List<Recordset>) #txt
wr0 f61 @C|.xml '<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<elementInfo>
    <language>
        <name>writeDocumentWithMailMergeTable(
CompositeObject,String,
String,String,String,
List&lt;String&gt;,List&lt;Recordset&gt;)</name>
        <nameStyle>108,5,7
</nameStyle>
        <desc>Produces a document with a list of merge fields and &#13;
with the help of a document factory Object. The Merge Mail With Regions is supported.&#13;
The Document Factory Object is a Java Object that can parse a document model&#13;
that contains mergefields and replace those mergefields by some String Data.&#13;
&#13;
A Mail Merge Region is a Table in the template which rows are going to be automatically filled with some data.&#13;
Each table in the template has a name and is set by a Start Mergefield(TableStart:nameOfTheTable).&#13;
To be able to perform this operation, one may provide the list of the tables names, the merge fields names for each table and the data (rows).&#13;
If there is no table in the given template, or no match between your data and the tables names/fieldsnames, these callables just ignore the tables&#13;
and perform normal mail merge.&#13;
&#13;
This callable takes some mandatory and some optional input parameters.&#13;
Mandatory input Parameters:&#13;
-&gt; TemplatePath: this is the path of the template (document model)&#13;
-&gt; data: A CompositeObject (DataClass). &#13;
The values of the DataClass fields are going to be used to fill corresponding simple merge fields.&#13;
&#13;
Optional input parameters:&#13;
-&gt; optionalOutputPath: where to store the created java.io.File. By default "ivy_RIA_files"&#13;
-&gt; optionalOutputFormat: by default the first supported one (in general it will be "doc"&#13;
-&gt; optionalLetterName: the file name of the letter. By default "letter"+ the nanoTime, &#13;
to be sure the file doesn''t overwrite any other.&#13;
-&gt; Data for filling some tables: list of table names and a List of Recordsets. &#13;
Each list of table names is filled with the corresponding RecordSet (table name at index x corresponds to the recordset at the same index in the list).&#13;
&#13;
It returns a FileOperationMessage Object that contains:&#13;
a Type indicating if the operation was successfull,&#13;
a message in the Session User language,&#13;
a list of java.io.File that were created during the process.&#13;
In this callable just one java.io.File is created. So the list of created File contains only one File in case of success.</desc>
    </language>
</elementInfo>
' #txt
wr0 f61 1931 51 26 26 -171 -37 #rect
wr0 f61 res:/webContent/icons/doc-factory-logo.png?small #fDecoratorIcon
wr0 f62 actionTable 'out=in;
' #txt
wr0 f62 actionCode '
import ch.ivyteam.ivy.addons.docfactory.FileUtil;

// if desired format not valid, we take the first supportedFormat
if(in.#outputFormat == null || in.outputFormat.trim().equalsIgnoreCase("") 
	|| !in.documentFactory.isFormatSupported(in.outputFormat)){
	if(in.documentFactory.getSupportedFormats().size()>0){
		out.outputFormat=in.documentFactory.getSupportedFormats().get(0);
	}
}

//if desired letter name not valid, we take the name "letter_nanoTime()"
if(in.#serialLetterName == null || in.serialLetterName.trim().equalsIgnoreCase("")
	|| !ch.ivyteam.ivy.addons.docfactory.FileUtil.isFileNameValid(in.serialLetterName)){
		out.serialLetterName = "letter_"+System.nanoTime();
}

//if desired outputPath is not valid, we take "ivy_RIA_Files"
if(in.outputPath==null || in.outputPath.trim().equalsIgnoreCase("")){
	out.outputPath="ivy_RIA_files";
}

' #txt
wr0 f62 @C|.xml '<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<elementInfo>
    <language>
        <name>Check the outputFormat / 
outputPath / outputLetterName
</name>
        <nameStyle>56,7,9
</nameStyle>
    </language>
</elementInfo>
' #txt
wr0 f62 1926 188 36 24 -183 -18 #rect
wr0 f63 actionTable 'out=in;
' #txt
wr0 f63 actionCode 'import ch.ivyteam.ivy.addons.docfactory.DocumentTemplate;
import java.util.Hashtable;
Hashtable htable = new Hashtable();

if(in.tablesNamesList.size()>0 && 
	in.ListOfRecordsets.size()==in.tablesNamesList.size()){
	int i=0;
	for(String s : in.tablesNamesList)
	{
		htable.put(s,in.ListOfRecordsets.get(i));
		i++;
	}
}
out.documentTemplate = new DocumentTemplate(in.templatePath,in.outputPath, in.serialLetterName,in.outputFormat,in.data,htable);' #txt
wr0 f63 @C|.xml '<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<elementInfo>
    <language>
        <name>build DocumentTemplate</name>
        <nameStyle>22,7
</nameStyle>
    </language>
</elementInfo>
' #txt
wr0 f63 1926 228 36 24 -160 -9 #rect
wr0 f64 actionTable 'out=in;
' #txt
wr0 f64 actionCode 'import ch.ivyteam.ivy.addons.docfactory.BaseDocFactory;

in.documentFactory= BaseDocFactory.getInstance();' #txt
wr0 f64 @C|.xml '<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<elementInfo>
    <language>
        <name>make the documentFactory 
Object</name>
        <nameStyle>32,7
</nameStyle>
    </language>
</elementInfo>
' #txt
wr0 f64 1926 140 36 24 -168 -23 #rect
wr0 f65 actionTable 'out=in;
' #txt
wr0 f65 actionCode out.fileOperationMessage=in.documentFactory.generateDocument(in.documentTemplate); #txt
wr0 f65 @C|.xml '<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<elementInfo>
    <language>
        <name>write the serial letter</name>
        <nameStyle>23,7
</nameStyle>
    </language>
</elementInfo>
' #txt
wr0 f65 1926 292 36 24 -139 -9 #rect
wr0 f66 expr out #txt
wr0 f66 1944 164 1944 188 #arcP
wr0 f67 expr out #txt
wr0 f67 1944 212 1944 228 #arcP
wr0 f68 expr out #txt
wr0 f68 1944 252 1944 292 #arcP
wr0 f69 expr out #txt
wr0 f69 1944 77 1944 140 #arcP
wr0 f70 1931 363 26 26 14 0 #rect
wr0 f70 res:/webContent/icons/doc-factory-logo.png?small #fDecoratorIcon
wr0 f71 expr out #txt
wr0 f71 1944 316 1944 363 #arcP
wr0 f72 inParamDecl '<String optionalOutputpath,String optionalLetterName,String optionalOutputFormat,String templatePath,CompositeObject DataForMailMergeOutOfTables,List<CompositeObject> parentTableDatas,List<List<CompositeObject>> nestedChildrenTableDatas> param;' #txt
wr0 f72 inParamInfo 'DataForMailMergeOutOfTables.description=Ivy data class object used for the normal merge fields\: the properties names of the object are the mergefields names. The values of these properties will be written in the document at the place of the corresponding mergefields. 
nestedChildrenTableDatas.description=Second level tables (tables inside the first level tables) data.
optionalLetterName.description=Produced document name (default is "letter" + nanotime)
optionalOutputFormat.description=Output format among "doc", "docx", "pdf", "txt", "html". Default is "doc".
optionalOutputpath.description=Output directory path (default is ''%IVY-ROOT-PATH%/ivy_RIA_files/)
parentTableDatas.description=First level tables data.
templatePath.description=The template path. ' #txt
wr0 f72 inParamTable 'out.data=param.DataForMailMergeOutOfTables;
out.ListOfCompositeObjectsToFillTheTables=param.nestedChildrenTableDatas;
out.ListOfParentCompositeObjects=param.parentTableDatas;
out.outputFormat=param.optionalOutputFormat;
out.outputPath=param.optionalOutputpath;
out.serialLetterName=param.optionalLetterName;
out.templatePath=param.templatePath;
' #txt
wr0 f72 outParamDecl '<ch.ivyteam.ivy.addons.docfactory.FileOperationMessage fileOperationMessage> result;' #txt
wr0 f72 outParamInfo 'fileOperationMessage.description=Result containing a Type indicating if the operation was successfull, a message in the Session User language, a list of java.io.File that were created during the process.' #txt
wr0 f72 outParamTable 'result.fileOperationMessage=in.fileOperationMessage;
' #txt
wr0 f72 callSignature writeDocumentWithMailMergeNestedTable(String,String,String,String,CompositeObject,List<CompositeObject>,List<List<CompositeObject>>) #txt
wr0 f72 @C|.xml '<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<elementInfo>
    <language>
        <name>writeDocumentWithMailMergeNestedTable(
String,String,String,String,
List&lt;CompositeObject&gt;,List&lt;List&lt;CompositeObject&gt;&gt;)</name>
        <nameStyle>118,5,7
</nameStyle>
        <desc>Produces a document with the data included in  a DataClass Object. &#13;
The Merge Mail With Nested Regions is supported.&#13;
Just One Level of Nested Regions is supported in this sub Process.&#13;
The List&lt;CompositeObject&gt;  (List of Ivy DataClasses) parameter is used as parent Table.&#13;
The  List&lt;List&lt;CompositeObject&gt;&gt;  (List of List of Ivy DataClasses) parameter is used as child Table.&#13;
&#13;
The Document Factory Object is a Java Object that can parse a document model&#13;
that contains mergefields and replace those mergefields by some String Data.&#13;
&#13;
It returns a FileOperationMessage Object that contains:&#13;
a Type indicating if the operation was successfull,&#13;
a message in the Session User language,&#13;
a list of java.io.File that were created during the process, just one java.io.File should be created.</desc>
    </language>
</elementInfo>
' #txt
wr0 f72 2779 43 26 26 26 -24 #rect
wr0 f72 res:/webContent/icons/doc-factory-logo.png?small #fDecoratorIcon
wr0 f73 actionTable 'out=in;
' #txt
wr0 f73 actionCode 'import ch.ivyteam.ivy.addons.docfactory.BaseDocFactory;
in.documentFactory= BaseDocFactory.getInstance();' #txt
wr0 f73 @C|.xml '<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<elementInfo>
    <language>
        <name>make the documentFactory 
Object</name>
        <nameStyle>32,7,9
</nameStyle>
    </language>
</elementInfo>
' #txt
wr0 f73 2774 132 36 24 22 -15 #rect
wr0 f74 actionTable 'out=in;
' #txt
wr0 f74 actionCode '
import ch.ivyteam.ivy.addons.docfactory.DocumentTemplate;
try{
	in.documentTemplate = new DocumentTemplate(in.templatePath,in.outputPath,in.serialLetterName,in.outputFormat,in.data,in.ListOfParentCompositeObjects,in.ListOfCompositeObjectsToFillTheTables);
	out.fileOperationMessage = 
in.documentTemplate.generateDocument();
}catch (Throwable t){
	ivy.log.error(t.getMessage(),t);
}

' #txt
wr0 f74 @C|.xml '<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<elementInfo>
    <language>
        <name>write the serialLetter</name>
        <nameStyle>22,7,9
</nameStyle>
    </language>
</elementInfo>
' #txt
wr0 f74 2774 284 36 24 22 -9 #rect
wr0 f75 actionTable 'out=in;
' #txt
wr0 f75 actionCode 'import ch.ivyteam.ivy.addons.docfactory.FileUtil;

// if desired format not valid, we take the first supportedFormat
if(in.#outputFormat == null || in.outputFormat.trim().equalsIgnoreCase("") 
	|| !in.documentFactory.isFormatSupported(in.outputFormat)){
	if(in.documentFactory.getSupportedFormats().size()>0){
		out.outputFormat=in.documentFactory.getSupportedFormats().get(0);
	}
}

//if desired letter name not valid, we take the name "letter_nanoTime()"
if(in.#serialLetterName == null || in.serialLetterName.trim().equalsIgnoreCase("")
	|| !ch.ivyteam.ivy.addons.docfactory.FileUtil.isFileNameValid(in.serialLetterName)){
		out.serialLetterName = "letter_"+System.nanoTime();
}

//if desired outputPath is not valid, we take "ivy_RIA_Files"
if(in.outputPath==null || in.outputPath.trim().equalsIgnoreCase("")){
	out.outputPath="ivy_RIA_files";
}

' #txt
wr0 f75 @C|.xml '<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<elementInfo>
    <language>
        <name>Check the outputFormat / 
outputPath / outputLetterName </name>
        <nameStyle>56,7,9
</nameStyle>
    </language>
</elementInfo>
' #txt
wr0 f75 2774 204 36 24 22 -18 #rect
wr0 f76 expr out #txt
wr0 f76 2792 156 2792 204 #arcP
wr0 f77 expr out #txt
wr0 f77 2792 228 2792 284 #arcP
wr0 f78 expr out #txt
wr0 f78 2792 69 2792 132 #arcP
wr0 f79 2779 363 26 26 14 0 #rect
wr0 f79 res:/webContent/icons/doc-factory-logo.png?small #fDecoratorIcon
wr0 f80 expr out #txt
wr0 f80 2792 308 2792 363 #arcP
wr0 f81 actionTable 'out=in;
' #txt
wr0 f81 actionCode 'import ch.ivyteam.ivy.addons.docfactory.BaseDocFactory;
in.documentFactory= BaseDocFactory.getInstance();' #txt
wr0 f81 @C|.xml '<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<elementInfo>
    <language>
        <name>make the documentFactory 
Object</name>
        <nameStyle>32,7,9
</nameStyle>
    </language>
</elementInfo>
' #txt
wr0 f81 3174 132 36 24 22 -15 #rect
wr0 f82 actionTable 'out=in;
' #txt
wr0 f82 actionCode 'import ch.ivyteam.ivy.addons.docfactory.FileUtil;

// if desired format not valid, we take the first supportedFormat
if(in.#outputFormat == null || in.outputFormat.trim().equalsIgnoreCase("") 
	|| !in.documentFactory.isFormatSupported(in.outputFormat)){
	if(in.documentFactory.getSupportedFormats().size()>0){
		out.outputFormat=in.documentFactory.getSupportedFormats().get(0);
	}
}

//if desired letter name not valid, we take the name "letter_nanoTime()"
if(in.#serialLetterName == null || in.serialLetterName.trim().equalsIgnoreCase("")
	|| !ch.ivyteam.ivy.addons.docfactory.FileUtil.isFileNameValid(in.serialLetterName)){
		out.serialLetterName = "letter_"+System.nanoTime();
}

//if desired outputPath is not valid, we take "ivy_RIA_Files"
if(in.outputPath==null || in.outputPath.trim().equalsIgnoreCase("")){
	out.outputPath="ivy_RIA_files";
}

' #txt
wr0 f82 @C|.xml '<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<elementInfo>
    <language>
        <name>Check the outputFormat / 
outputPath / outputLetterName </name>
        <nameStyle>56,7,9
</nameStyle>
    </language>
</elementInfo>
' #txt
wr0 f82 3174 204 36 24 22 -18 #rect
wr0 f83 actionTable 'out=in;
' #txt
wr0 f83 actionCode '
import ch.ivyteam.ivy.addons.docfactory.DocumentTemplate;
try{
	in.documentTemplate = new DocumentTemplate(in.templatePath,in.outputPath,in.serialLetterName,in.outputFormat,in.TreeDataForNestedMailMerge);
	out.fileOperationMessage = 
in.documentTemplate.generateDocument();
}catch (Throwable t){
	ivy.log.error(t.getMessage(),t);
}

' #txt
wr0 f83 @C|.xml '<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<elementInfo>
    <language>
        <name>write the serialLetter</name>
        <nameStyle>22,7,9
</nameStyle>
    </language>
</elementInfo>
' #txt
wr0 f83 3174 284 36 24 22 -9 #rect
wr0 f84 inParamDecl '<String optionalOutputpath,String optionalLetterName,String optionalOutputFormat,String templatePath,Tree treeData> param;' #txt
wr0 f84 inParamInfo 'optionalLetterName.description=Produced document name (default is "letter" + nanotime)
optionalOutputFormat.description=Output format among "doc", "docx", "pdf", "txt", "html". Default is "doc".
optionalOutputpath.description=Output directory path (default is ''%IVY-ROOT-PATH%/ivy_RIA_files/)
templatePath.description=The template path. 
treeData.description=Tree data for the tables and nested tables. Just One Level of Nested Regions is supported in this sub Process.' #txt
wr0 f84 inParamTable 'out.outputFormat=param.optionalOutputFormat;
out.outputPath=param.optionalOutputpath;
out.serialLetterName=param.optionalLetterName;
out.templatePath=param.templatePath;
out.TreeDataForNestedMailMerge=param.treeData;
' #txt
wr0 f84 outParamDecl '<ch.ivyteam.ivy.addons.docfactory.FileOperationMessage fileOperationMessage> result;' #txt
wr0 f84 outParamInfo 'fileOperationMessage.description=Result containing a Type indicating if the operation was successfull, a message in the Session User language, a list of java.io.File that were created during the process.' #txt
wr0 f84 outParamTable 'result.fileOperationMessage=in.fileOperationMessage;
' #txt
wr0 f84 callSignature writeDocumentWithMailMergeNestedTableWithTree(String,String,String,String,Tree) #txt
wr0 f84 @C|.xml '<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<elementInfo>
    <language>
        <name>writeDocumentWithMailMergeNestedTableWithTree(
String,String,String,String,
Tree)</name>
        <nameStyle>81,5,7
</nameStyle>
        <desc>Produces a document with the data included in &#13;
a Tree Object. The Merge Mail With Nested Regions is supported.&#13;
Just One Level of Nested Regions is supported in this sub Process.&#13;
The Tree is used to generate the Mail Merge with Nested Regions.&#13;
The Object Value of the Node should be a DataClass (CompositeObject) and is used &#13;
to provide the merge fields data outside of the Nested Tables.&#13;
The Document Factory Object is a Java Object that can parse a document model&#13;
that contains mergefields and replace those mergefields by some String Data.&#13;
&#13;
It returns a FileOperationMessage Object that contains:&#13;
a Type indicating if the operation was successfull,&#13;
a message in the Session User language,&#13;
a list of java.io.File that were created during the process, just one java.io.File is created.</desc>
    </language>
</elementInfo>
' #txt
wr0 f84 3179 43 26 26 26 -24 #rect
wr0 f84 res:/webContent/icons/doc-factory-logo.png?small #fDecoratorIcon
wr0 f85 expr out #txt
wr0 f85 3192 156 3192 204 #arcP
wr0 f86 expr out #txt
wr0 f86 3192 228 3192 284 #arcP
wr0 f87 expr out #txt
wr0 f87 3192 69 3192 132 #arcP
wr0 f88 3179 371 26 26 14 0 #rect
wr0 f88 res:/webContent/icons/doc-factory-logo.png?small #fDecoratorIcon
wr0 f89 expr out #txt
wr0 f89 3192 308 3192 371 #arcP
wr0 f90 inParamDecl '<String optionalOutputpath,String optionalLetterName,String optionalOutputFormat,String templatePath,CompositeObject aData,List<CompositeObject> nestedListOfDatas> param;' #txt
wr0 f90 inParamInfo 'aData.description=Data (CompositeObject) used to provide the merge fields data outside of the Nested Tables.
nestedListOfDatas.description=A List of Dataclasses used for the mail Merge with nested tables. Each dataclass may contain lists of other nested dataclasses and so on... .There is no limit in nesting regions.
optionalLetterName.description=Produced document name (default is "letter" + nanotime)
optionalOutputFormat.description=Output format among "doc", "docx", "pdf", "txt", "html". Default is "doc".
optionalOutputpath.description=Output directory path (default is ''%IVY-ROOT-PATH%/ivy_RIA_files/)
templatePath.description=The template path. ' #txt
wr0 f90 inParamTable 'out.data=param.aData;
out.ListOfParentCompositeObjects=param.nestedListOfDatas;
out.outputFormat=param.optionalOutputFormat;
out.outputPath=param.optionalOutputpath;
out.serialLetterName=param.optionalLetterName;
out.templatePath=param.templatePath;
' #txt
wr0 f90 outParamDecl '<ch.ivyteam.ivy.addons.docfactory.FileOperationMessage fileOperationMessage> result;' #txt
wr0 f90 outParamInfo 'fileOperationMessage.description=Result containing a Type indicating if the operation was successfull, a message in the Session User language, a list of java.io.File that were created during the process.' #txt
wr0 f90 outParamTable 'result.fileOperationMessage=in.fileOperationMessage;
' #txt
wr0 f90 callSignature writeDocumentWithMailMergeNestedTableWithListOfDatas(String,String,String,String,CompositeObject,List<CompositeObject>) #txt
wr0 f90 @C|.xml '<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<elementInfo>
    <language>
        <name>writeDocumentWithMailMergeNestedTableWithListOfDatas(
String,String,String,String,
CompositeObject, List&lt;CompositeObject&gt;)</name>
        <nameStyle>122,5,7
</nameStyle>
        <desc>Produces a document with the data from the given Data object. &#13;
The Merge Mail With Nested Regions is supported and the each data in the List&lt;CompositeObject&gt; represents a table.&#13;
&#13;
The DataClass (CompositeObject) is used to provide the merge fields data outside of the Nested Tables.&#13;
A List of Dataclasses is be used to do the mail Merge with nested tables.&#13;
Each dataclass may contain lists of other nested dataclasses and so on... .There is no limit in nesting regions.&#13;
&#13;
It returns a FileOperationMessage Object that contains:&#13;
a Type indicating if the operation was successfull,&#13;
a message in the Session User language,&#13;
a list of java.io.File that were created during the process, just one java.io.File is created.</desc>
    </language>
</elementInfo>
' #txt
wr0 f90 3611 43 26 26 26 -24 #rect
wr0 f90 res:/webContent/icons/doc-factory-logo.png?small #fDecoratorIcon
wr0 f91 actionTable 'out=in;
' #txt
wr0 f91 actionCode '
import ch.ivyteam.ivy.addons.docfactory.DocumentTemplate;
try{
	in.documentTemplate = new DocumentTemplate(in.templatePath,in.outputPath,in.serialLetterName,in.outputFormat,in.data,in.ListOfParentCompositeObjects);
	out.fileOperationMessage = 
in.documentTemplate.generateDocument();
}catch (Throwable t){
	ivy.log.error(t.getMessage(),t);
}

' #txt
wr0 f91 @C|.xml '<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<elementInfo>
    <language>
        <name>write the serialLetter</name>
        <nameStyle>22,7,9
</nameStyle>
    </language>
</elementInfo>
' #txt
wr0 f91 3606 284 36 24 22 -9 #rect
wr0 f92 actionTable 'out=in;
' #txt
wr0 f92 actionCode 'import ch.ivyteam.ivy.addons.docfactory.FileUtil;

// if desired format not valid, we take the first supportedFormat
if(in.#outputFormat == null || in.outputFormat.trim().equalsIgnoreCase("") 
	|| !in.documentFactory.isFormatSupported(in.outputFormat)){
	if(in.documentFactory.getSupportedFormats().size()>0){
		out.outputFormat=in.documentFactory.getSupportedFormats().get(0);
	}
}

//if desired letter name not valid, we take the name "letter_nanoTime()"
if(in.#serialLetterName == null || in.serialLetterName.trim().equalsIgnoreCase("")
	|| !ch.ivyteam.ivy.addons.docfactory.FileUtil.isFileNameValid(in.serialLetterName)){
		out.serialLetterName = "letter_"+System.nanoTime();
}

//if desired outputPath is not valid, we take "ivy_RIA_Files"
if(in.outputPath==null || in.outputPath.trim().equalsIgnoreCase("")){
	out.outputPath="ivy_RIA_files";
}

' #txt
wr0 f92 @C|.xml '<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<elementInfo>
    <language>
        <name>Check the outputFormat / 
outputPath / outputLetterName </name>
        <nameStyle>56,7,9
</nameStyle>
    </language>
</elementInfo>
' #txt
wr0 f92 3606 204 36 24 22 -18 #rect
wr0 f93 actionTable 'out=in;
' #txt
wr0 f93 actionCode 'import ch.ivyteam.ivy.addons.docfactory.BaseDocFactory;
in.documentFactory= BaseDocFactory.getInstance();' #txt
wr0 f93 @C|.xml '<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<elementInfo>
    <language>
        <name>make the documentFactory 
Object</name>
        <nameStyle>32,7,9
</nameStyle>
    </language>
</elementInfo>
' #txt
wr0 f93 3606 132 36 24 22 -15 #rect
wr0 f94 expr out #txt
wr0 f94 3624 156 3624 204 #arcP
wr0 f95 expr out #txt
wr0 f95 3624 228 3624 284 #arcP
wr0 f96 expr out #txt
wr0 f96 3624 69 3624 132 #arcP
wr0 f97 3611 371 26 26 14 0 #rect
wr0 f97 res:/webContent/icons/doc-factory-logo.png?small #fDecoratorIcon
wr0 f98 expr out #txt
wr0 f98 3624 308 3624 371 #arcP
wr0 f99 @C|.xml '<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<elementInfo>
    <language>
        <name>These callables produce a document with a list of merge fields and 
with the help of a document factory Object. The Merge Mail With Nested Regions is supported.
The Document Factory Object is a Java Object that can parse a document model
that contains mergefields and replace those mergefields by some String Data.

Nested mail merge regions are at least two regions in which one is defined entirely inside the other, so they are nested in one another.
The Names of the tables or regions in the template are given by a Start Mergefield(TableStart:nameOfTheTable).

This callable takes some mandatory and some optional input parameters.
Mandatory input Parameters:
-&gt; TemplatePath: this is the path of the template (document model)
-&gt; Other Input parameters containing the data (Tree, List&lt;CompositeObject&gt; etc...)

Optional input parameters:
-&gt; optionalOutputPath: where to store the created java.io.File. By default &quot;ivy_RIA_files&quot;
-&gt; optionalOutputFormat: by default the first supported one (in general it will be &quot;doc&quot;
-&gt; optionalLetterName: the file name of the letter. By default &quot;letter&quot;+ the nanoTime, 
to be sure the file doesn''t overwrite any other.

It returns a FileOperationMessage Object that contains:
a Type indicating if the operation was successfull,
a message in the Session User language,
a list of java.io.File that were created during the process.

In these callables, just one java.io.File should be created.</name>
        <nameStyle>160,0,7,23
156,7,9
233,7,21
14,1,2,7,21
3,7,21
72,7,9
27,0,7,23
68,7,9
83,7,15
1,7,9
26,0,7,23
319,7,9
55,0,7,23
154,7,9
61,0,7,23
</nameStyle>
    </language>
</elementInfo>
' #txt
wr0 f99 2771 427 1002 410 -371 -200 #rect
wr0 f99 -657956|-1|-16777216 #nodeStyle
wr0 f100 inParamDecl '<CompositeObject data,String optionalOutputpath,String optionalLetterName,String optionalOutputFormat,String templatePath> param;' #txt
wr0 f100 inParamInfo 'data.description=Ivy data class object\: the properties names of the object are the mergefields names. The values of these properties will be written in the document at the place of the corresponding mergefields. The collections of Serializables inside this bean are used for supporting the mail merge with region.
optionalLetterName.description=Produced document name (default is "letter" + nanotime)
optionalOutputFormat.description=Output format among "doc", "docx", "pdf", "txt", "html". Default is "doc".
optionalOutputpath.description=Output directory path (default is ''%IVY-ROOT-PATH%/ivy_RIA_files/)
templatePath.description=The template path. ' #txt
wr0 f100 inParamTable 'out.data=param.data;
out.outputFormat=param.optionalOutputFormat;
out.outputPath=param.optionalOutputpath;
out.serialLetterName=param.optionalLetterName;
out.templatePath=param.templatePath;
' #txt
wr0 f100 outParamDecl '<ch.ivyteam.ivy.addons.docfactory.FileOperationMessage fileOperationMessage> result;' #txt
wr0 f100 outParamInfo 'fileOperationMessage.description=Result containing a Type indicating if the operation was successfull, a message in the Session User language, a list of java.io.File that were created during the process.' #txt
wr0 f100 outParamTable 'result.fileOperationMessage=in.fileOperationMessage;
' #txt
wr0 f100 callSignature writeDocumentWithNestedDataClass(CompositeObject,String,String,String,String) #txt
wr0 f100 @C|.xml '<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<elementInfo>
    <language>
        <name>writeDocumentWithNestedDataClass(&#13;
CompositeObject, &#13;
String,String,String,String)</name>
        <desc>This callable produces a document with a data (DataClass) and &#13;
with the help of a document factory Object. &#13;
&#13;
The Document Factory Object is a Java Object that can parse a document model&#13;
that contains mergefields and replace those mergefields by some String Data.&#13;
&#13;
This callable takes some mandatory and some optional input parameters.&#13;
Mandatory input Parameters:&#13;
-&gt; TemplatePath: this is the path of the template (document model)&#13;
-&gt; data: A CompositeObject (DataClass). &#13;
The values of the DataClass fields are going to be used to fill the template and to produce the document.&#13;
The fields of the data have to be named like the fields of the template. &#13;
If the DataClass Object contains some List of other DataClasses, they will be used in mail merge with nested regions.&#13;
&#13;
Optional input parameters:&#13;
-&gt; optionalOutputPath: where to store the created java.io.File. By default "ivy_RIA_files"&#13;
-&gt; optionalOutputFormat: by default the first supported one (in general it will be "doc"&#13;
-&gt; optionalLetterName: the file name of the letter. By default "letter"+ the nanoTime, &#13;
to be sure the file doesn''t overwrite any other.&#13;
&#13;
It returns a FileOperationMessage Object that contains:&#13;
a Type indicating if the operation was successfull,&#13;
a message in the Session User language,&#13;
a list of java.io.File that were created during the process.&#13;
&#13;
In this callable, just one java.io.File should be created.</desc>
    </language>
</elementInfo>
' #txt
wr0 f100 979 51 26 26 -161 -38 #rect
wr0 f100 res:/webContent/icons/doc-factory-logo.png?small #fDecoratorIcon
wr0 f101 979 363 26 26 14 0 #rect
wr0 f101 res:/webContent/icons/doc-factory-logo.png?small #fDecoratorIcon
wr0 f102 actionTable 'out=in;
' #txt
wr0 f102 actionCode 'import ch.ivyteam.ivy.addons.docfactory.BaseDocFactory;

in.documentFactory= BaseDocFactory.getInstance();' #txt
wr0 f102 @C|.xml '<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<elementInfo>
    <language>
        <name>make the documentFactory 
Object</name>
        <nameStyle>32,7
</nameStyle>
    </language>
</elementInfo>
' #txt
wr0 f102 974 132 36 24 30 -16 #rect
wr0 f103 actionTable 'out=in;
' #txt
wr0 f103 actionCode '
import ch.ivyteam.ivy.addons.docfactory.FileUtil;

// if desired format not valid, we take the first supportedFormat
if(in.#outputFormat == null || in.outputFormat.trim().equalsIgnoreCase("") 
	|| !in.documentFactory.isFormatSupported(in.outputFormat)){
	if(in.documentFactory.getSupportedFormats().size()>0){
		out.outputFormat=in.documentFactory.getSupportedFormats().get(0);
	}
}

//if desired letter name not valid, we take the name "letter_nanoTime()"
if(in.#serialLetterName == null || in.serialLetterName.trim().equalsIgnoreCase("")
	|| !ch.ivyteam.ivy.addons.docfactory.FileUtil.isFileNameValid(in.serialLetterName)){
		out.serialLetterName = "letter_"+System.nanoTime();
}

//if desired outputPath is not valid, we take "ivy_RIA_Files"
if(in.outputPath==null || in.outputPath.trim().equalsIgnoreCase("")){
	out.outputPath="ivy_RIA_files";
}

' #txt
wr0 f103 @C|.xml '<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<elementInfo>
    <language>
        <name>Check the outputFormat / 
outputPath / outputLetterName
</name>
        <nameStyle>56,7,9
</nameStyle>
    </language>
</elementInfo>
' #txt
wr0 f103 974 196 36 24 22 -18 #rect
wr0 f104 actionTable 'out=in;
' #txt
wr0 f104 actionCode out.fileOperationMessage=in.documentFactory.generateDocument(in.documentTemplate); #txt
wr0 f104 @C|.xml '<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<elementInfo>
    <language>
        <name>write the serial letter</name>
        <nameStyle>23,7
</nameStyle>
    </language>
</elementInfo>
' #txt
wr0 f104 974 284 36 24 20 -2 #rect
wr0 f105 actionTable 'out=in;
' #txt
wr0 f105 actionCode 'import ch.ivyteam.ivy.addons.docfactory.DocumentTemplate;

out.documentTemplate = new DocumentTemplate(in.templatePath,in.outputPath, in.serialLetterName,in.outputFormat,in.data);
out.documentTemplate.putDataAsSourceForMailMerge(in.data);
' #txt
wr0 f105 @C|.xml '<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<elementInfo>
    <language>
        <name>build DocumentTemplate</name>
        <nameStyle>22,7
</nameStyle>
    </language>
</elementInfo>
' #txt
wr0 f105 974 236 36 24 20 -2 #rect
wr0 f106 expr out #txt
wr0 f106 992 220 992 236 #arcP
wr0 f107 expr out #txt
wr0 f107 992 260 992 284 #arcP
wr0 f108 expr out #txt
wr0 f108 992 77 992 132 #arcP
wr0 f109 expr out #txt
wr0 f109 992 156 992 196 #arcP
wr0 f110 expr out #txt
wr0 f110 992 308 992 363 #arcP
>Proto wr0 .xml '<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<elementInfo>
    <language>
        <swimlaneLabel></swimlaneLabel>
        <swimlaneLabel></swimlaneLabel>
        <swimlaneLabel></swimlaneLabel>
        <swimlaneLabel></swimlaneLabel>
        <swimlaneLabel></swimlaneLabel>
    </language>
    <swimlaneOrientation>false</swimlaneOrientation>
    <swimlaneSize>115</swimlaneSize>
    <swimlaneSize>64</swimlaneSize>
    <swimlaneSize>87</swimlaneSize>
    <swimlaneSize>72</swimlaneSize>
    <swimlaneColor>-1051265</swimlaneColor>
    <swimlaneColor>-10027162</swimlaneColor>
    <swimlaneColor>-103</swimlaneColor>
    <swimlaneColor>-3368449</swimlaneColor>
</elementInfo>
' #txt
>Proto wr0 .type ch.ivyteam.ivy.addons.docfactory.WriteSerialLetter #txt
>Proto wr0 .processKind CALLABLE_SUB #txt
>Proto wr0 0 0 32 24 18 0 #rect
>Proto wr0 @|BIcon #fIcon
wr0 f7 mainOut f6 tail #connect
wr0 f6 head f1 mainIn #connect
wr0 f0 mainOut f2 tail #connect
wr0 f2 head f4 mainIn #connect
wr0 f4 mainOut f5 tail #connect
wr0 f5 head f3 mainIn #connect
wr0 f3 mainOut f8 tail #connect
wr0 f8 head f7 mainIn #connect
wr0 f10 mainOut f13 tail #connect
wr0 f13 head f12 mainIn #connect
wr0 f12 mainOut f15 tail #connect
wr0 f15 head f14 mainIn #connect
wr0 f14 mainOut f17 tail #connect
wr0 f17 head f16 mainIn #connect
wr0 f16 mainOut f19 tail #connect
wr0 f19 head f18 mainIn #connect
wr0 f18 mainOut f21 tail #connect
wr0 f21 head f20 mainIn #connect
wr0 f25 mainOut f26 tail #connect
wr0 f26 head f24 mainIn #connect
wr0 f24 mainOut f27 tail #connect
wr0 f27 head f23 mainIn #connect
wr0 f22 mainOut f28 tail #connect
wr0 f28 head f25 mainIn #connect
wr0 f23 mainOut f30 tail #connect
wr0 f30 head f29 mainIn #connect
wr0 f32 mainOut f35 tail #connect
wr0 f35 head f34 mainIn #connect
wr0 f34 mainOut f36 tail #connect
wr0 f36 head f33 mainIn #connect
wr0 f31 mainOut f37 tail #connect
wr0 f37 head f32 mainIn #connect
wr0 f33 mainOut f39 tail #connect
wr0 f39 head f38 mainIn #connect
wr0 f42 mainOut f44 tail #connect
wr0 f44 head f41 mainIn #connect
wr0 f41 mainOut f45 tail #connect
wr0 f45 head f43 mainIn #connect
wr0 f40 mainOut f46 tail #connect
wr0 f46 head f42 mainIn #connect
wr0 f43 mainOut f48 tail #connect
wr0 f48 head f47 mainIn #connect
wr0 f53 mainOut f55 tail #connect
wr0 f55 head f52 mainIn #connect
wr0 f52 mainOut f56 tail #connect
wr0 f56 head f51 mainIn #connect
wr0 f51 mainOut f57 tail #connect
wr0 f57 head f54 mainIn #connect
wr0 f50 mainOut f58 tail #connect
wr0 f58 head f53 mainIn #connect
wr0 f54 mainOut f60 tail #connect
wr0 f60 head f59 mainIn #connect
wr0 f64 mainOut f66 tail #connect
wr0 f66 head f62 mainIn #connect
wr0 f62 mainOut f67 tail #connect
wr0 f67 head f63 mainIn #connect
wr0 f63 mainOut f68 tail #connect
wr0 f68 head f65 mainIn #connect
wr0 f61 mainOut f69 tail #connect
wr0 f69 head f64 mainIn #connect
wr0 f65 mainOut f71 tail #connect
wr0 f71 head f70 mainIn #connect
wr0 f73 mainOut f76 tail #connect
wr0 f76 head f75 mainIn #connect
wr0 f75 mainOut f77 tail #connect
wr0 f77 head f74 mainIn #connect
wr0 f72 mainOut f78 tail #connect
wr0 f78 head f73 mainIn #connect
wr0 f74 mainOut f80 tail #connect
wr0 f80 head f79 mainIn #connect
wr0 f81 mainOut f85 tail #connect
wr0 f85 head f82 mainIn #connect
wr0 f82 mainOut f86 tail #connect
wr0 f86 head f83 mainIn #connect
wr0 f84 mainOut f87 tail #connect
wr0 f87 head f81 mainIn #connect
wr0 f83 mainOut f89 tail #connect
wr0 f89 head f88 mainIn #connect
wr0 f93 mainOut f94 tail #connect
wr0 f94 head f92 mainIn #connect
wr0 f92 mainOut f95 tail #connect
wr0 f95 head f91 mainIn #connect
wr0 f90 mainOut f96 tail #connect
wr0 f96 head f93 mainIn #connect
wr0 f91 mainOut f98 tail #connect
wr0 f98 head f97 mainIn #connect
wr0 f100 mainOut f108 tail #connect
wr0 f108 head f102 mainIn #connect
wr0 f102 mainOut f109 tail #connect
wr0 f109 head f103 mainIn #connect
wr0 f103 mainOut f106 tail #connect
wr0 f106 head f105 mainIn #connect
wr0 f105 mainOut f107 tail #connect
wr0 f107 head f104 mainIn #connect
wr0 f104 mainOut f110 tail #connect
wr0 f110 head f101 mainIn #connect
